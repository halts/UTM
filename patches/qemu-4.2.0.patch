From feb826622404551de3947cd0eb60ffb5d66a6c0e Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 24 Apr 2019 20:16:48 -0700
Subject: [PATCH 1/4] build: Add support for iOS host

Fix build errors with clang
Block driver modified to handle iOS
Slirp driver modified to handle iOS
Calls to system() conditioned on not iOS build
Support iOS icache flushing
---
 block.c                   |  2 +-
 block/file-posix.c        | 38 +++++++++++++++++++-----------
 configure                 | 49 ++++++++++++++++++++++++++++++++++++++-
 net/slirp.c               | 16 ++++++-------
 qga/commands-posix.c      |  6 +++++
 target/arm/arm-semi.c     |  2 ++
 target/m68k/m68k-semi.c   |  2 ++
 target/nios2/nios2-semi.c |  2 ++
 tcg/aarch64/tcg-target.h  | 10 ++++++++
 9 files changed, 104 insertions(+), 23 deletions(-)

diff --git a/block.c b/block.c
index 473eb6eeaa..4d10453a1c 100644
--- a/block.c
+++ b/block.c
@@ -52,7 +52,7 @@
 #ifdef CONFIG_BSD
 #include <sys/ioctl.h>
 #include <sys/queue.h>
-#ifndef __DragonFly__
+#if !defined(__DragonFly__) && !defined(CONFIG_IOS)
 #include <sys/disk.h>
 #endif
 #endif
diff --git a/block/file-posix.c b/block/file-posix.c
index 1b805bd938..98e34f12e8 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -40,7 +40,7 @@
 #include "scsi/pr-manager.h"
 #include "scsi/constants.h"
 
-#if defined(__APPLE__) && (__MACH__)
+#if defined(CONFIG_HOST_DEVICE) && defined(__APPLE__) && (__MACH__)
 #include <paths.h>
 #include <sys/param.h>
 #include <IOKit/IOKitLib.h>
@@ -177,7 +177,16 @@ typedef struct BDRVRawReopenState {
     bool check_cache_dropped;
 } BDRVRawReopenState;
 
-static int fd_open(BlockDriverState *bs);
+static int fd_open(BlockDriverState *bs)
+{
+    BDRVRawState *s = bs->opaque;
+
+    /* this is just to ensure s->fd is sane (its called by io ops) */
+    if (s->fd >= 0)
+        return 0;
+    return -EIO;
+}
+
 static int64_t raw_getlength(BlockDriverState *bs);
 
 typedef struct RawPosixAIOData {
@@ -248,6 +257,12 @@ static int raw_normalize_devicepath(const char **filename, Error **errp)
 }
 #endif
 
+#if defined(CONFIG_IOS)
+static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
+{
+    return -ENOTSUP; // not supported on iOS
+}
+#else /* CONFIG_IOS */
 /*
  * Get logical block size via ioctl. On success store it in @sector_size_p.
  */
@@ -280,6 +295,7 @@ static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
 
     return success ? 0 : -errno;
 }
+#endif /* !CONFIG_IOS */
 
 /**
  * Get physical block size of @fd.
@@ -2169,7 +2185,7 @@ again:
         }
         if (size == 0)
 #endif
-#if defined(__APPLE__) && defined(__MACH__)
+#if !defined(CONFIG_IOS) && defined(__APPLE__) && defined(__MACH__)
         {
             uint64_t sectors = 0;
             uint32_t sector_size = 0;
@@ -3045,6 +3061,8 @@ BlockDriver bdrv_file = {
 /***********************************************/
 /* host device */
 
+#if defined(CONFIG_HOST_DEVICE)
+
 #if defined(__APPLE__) && defined(__MACH__)
 static kern_return_t GetBSDPath(io_iterator_t mediaIterator, char *bsdPath,
                                 CFIndex maxPathSize, int flags);
@@ -3381,16 +3399,6 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 }
 #endif /* linux */
 
-static int fd_open(BlockDriverState *bs)
-{
-    BDRVRawState *s = bs->opaque;
-
-    /* this is just to ensure s->fd is sane (its called by io ops) */
-    if (s->fd >= 0)
-        return 0;
-    return -EIO;
-}
-
 static coroutine_fn int
 hdev_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -3778,6 +3786,8 @@ static BlockDriver bdrv_host_cdrom = {
 };
 #endif /* __FreeBSD__ */
 
+#endif /* CONFIG_HOST_DEVICE */
+
 static void bdrv_file_init(void)
 {
     /*
@@ -3785,6 +3795,7 @@ static void bdrv_file_init(void)
      * registered last will get probed first.
      */
     bdrv_register(&bdrv_file);
+#if defined(CONFIG_HOST_DEVICE)
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
     bdrv_register(&bdrv_host_cdrom);
@@ -3792,6 +3803,7 @@ static void bdrv_file_init(void)
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
     bdrv_register(&bdrv_host_cdrom);
 #endif
+#endif /* CONFIG_HOST_DEVICE */
 }
 
 block_init(bdrv_file_init);
diff --git a/configure b/configure
index 6099be1d84..2221ba58d2 100755
--- a/configure
+++ b/configure
@@ -504,6 +504,7 @@ debug_mutex="no"
 libpmem=""
 default_devices="yes"
 plugins="no"
+host_device_support="yes"
 
 supported_cpu="no"
 supported_os="no"
@@ -619,6 +620,19 @@ EOF
   compile_object
 }
 
+check_ios() {
+  cat > $TMPC <<EOF
+#ifdef __APPLE__
+#import "TargetConditionals.h" 
+#if !TARGET_OS_IPHONE
+#error TARGET_OS_IPHONE not true
+#endif
+#endif
+int main(void) { return 0; }
+EOF
+  compile_object
+}
+
 check_include() {
 cat > $TMPC <<EOF
 #include <$1>
@@ -652,7 +666,11 @@ elif check_define __DragonFly__ ; then
 elif check_define __NetBSD__; then
   targetos='NetBSD'
 elif check_define __APPLE__; then
-  targetos='Darwin'
+  if check_ios ; then
+    targetos='iOS'
+  else
+    targetos='Darwin'
+  fi
 else
   # This is a fatal error, but don't report it yet, because we
   # might be going to just print the --help text, or it might
@@ -857,6 +875,27 @@ Darwin)
   HOST_VARIANT_DIR="darwin"
   supported_os="yes"
 ;;
+iOS)
+  bsd="yes"
+  darwin="yes"
+  ios="yes"
+  hax="yes"
+  hvf="yes"
+  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  if [ "$cpu" = "x86_64" ] ; then
+    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
+    LDFLAGS="-arch x86_64 $LDFLAGS"
+  fi
+  host_device_support="no"
+  audio_drv_list=""
+  audio_possible_drivers=""
+  LDFLAGS="-framework CoreFoundation $LDFLAGS"
+  # Disable attempts to use ObjectiveC features in os/object.h since they
+  # won't work when we're compiling with gcc as a C compiler.
+  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
+  HOST_VARIANT_DIR="ios"
+  supported_os="yes"
+;;
 SunOS)
   solaris="yes"
   make="${MAKE-gmake}"
@@ -6599,6 +6638,7 @@ echo "libpmem support   $libpmem"
 echo "libudev           $libudev"
 echo "default devices   $default_devices"
 echo "plugin support    $plugins"
+echo "host device support  $host_device_support"
 
 if test "$supported_cpu" = "no"; then
     echo
@@ -6675,6 +6715,9 @@ if test "$default_devices" = "yes" ; then
 else
   echo "CONFIG_MINIKCONF_MODE=--allnoconfig" >> $config_host_mak
 fi
+if test "$host_device_support" = "yes" ; then
+  echo "CONFIG_HOST_DEVICE=y" >> $config_host_mak
+fi
 if test "$debug_tcg" = "yes" ; then
   echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
 fi
@@ -6724,6 +6767,10 @@ if test "$darwin" = "yes" ; then
   echo "CONFIG_DARWIN=y" >> $config_host_mak
 fi
 
+if test "$ios" = "yes" ; then
+  echo "CONFIG_IOS=y" >> $config_host_mak
+fi
+
 if test "$solaris" = "yes" ; then
   echo "CONFIG_SOLARIS=y" >> $config_host_mak
 fi
diff --git a/net/slirp.c b/net/slirp.c
index c4334ee876..5afb136d16 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -27,7 +27,7 @@
 #include "net/slirp.h"
 
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 #include <pwd.h>
 #include <sys/wait.h>
 #endif
@@ -90,7 +90,7 @@ typedef struct SlirpState {
     Slirp *slirp;
     Notifier poll_notifier;
     Notifier exit_notifier;
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     gchar *smb_dir;
 #endif
     GSList *fwd;
@@ -103,7 +103,7 @@ static QTAILQ_HEAD(, SlirpState) slirp_stacks =
 static int slirp_hostfwd(SlirpState *s, const char *redir_str, Error **errp);
 static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp);
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 static int slirp_smb(SlirpState *s, const char *exported_dir,
                      struct in_addr vserver_addr, Error **errp);
 static void slirp_smb_cleanup(SlirpState *s);
@@ -368,7 +368,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     struct in6_addr ip6_prefix;
     struct in6_addr ip6_host;
     struct in6_addr ip6_dns;
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     struct in_addr smbsrv = { .s_addr = 0 };
 #endif
     NetClientState *nc;
@@ -478,7 +478,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
         return -1;
     }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {
         error_setg(errp, "Failed to parse SMB address");
         return -1;
@@ -593,7 +593,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
             }
         }
     }
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     if (smb_export) {
         if (slirp_smb(s, smb_export, smbsrv, errp) < 0) {
             goto error;
@@ -805,7 +805,7 @@ void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)
 
 }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
@@ -920,7 +920,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir,
     return 0;
 }
 
-#endif /* !defined(_WIN32) */
+#endif /* !defined(_WIN32) && !defined(CONFIG_IOS) */
 
 static int guestfwd_can_read(void *opaque)
 {
diff --git a/qga/commands-posix.c b/qga/commands-posix.c
index 1c1a165dae..41e871fa86 100644
--- a/qga/commands-posix.c
+++ b/qga/commands-posix.c
@@ -33,6 +33,12 @@
 
 #ifndef CONFIG_HAS_ENVIRON
 #ifdef __APPLE__
+#include "TargetConditionals.h"
+#if !TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+#define APPLE_USE_CRT_EXTERNS
+#endif
+#endif
+#ifdef APPLE_USE_CRT_EXTERNS
 #include <crt_externs.h>
 #define environ (*_NSGetEnviron())
 #else
diff --git a/target/arm/arm-semi.c b/target/arm/arm-semi.c
index 6f7b6d801b..9e27f9254c 100644
--- a/target/arm/arm-semi.c
+++ b/target/arm/arm-semi.c
@@ -882,6 +882,7 @@ target_ulong do_arm_semihosting(CPUARMState *env)
         return clock() / (CLOCKS_PER_SEC / 100);
     case TARGET_SYS_TIME:
         return set_swi_errno(env, time(NULL));
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case TARGET_SYS_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -898,6 +899,7 @@ target_ulong do_arm_semihosting(CPUARMState *env)
             unlock_user(s, arg0, 0);
             return ret;
         }
+#endif /* CONFIG_IOS */
     case TARGET_SYS_ERRNO:
         return get_swi_errno(env);
     case TARGET_SYS_GET_CMDLINE:
diff --git a/target/m68k/m68k-semi.c b/target/m68k/m68k-semi.c
index 8e5fbfc8fa..598a1b78a2 100644
--- a/target/m68k/m68k-semi.c
+++ b/target/m68k/m68k-semi.c
@@ -402,6 +402,7 @@ void do_m68k_semihosting(CPUM68KState *env, int nr)
             result = isatty(arg0);
         }
         break;
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case HOSTED_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -420,6 +421,7 @@ void do_m68k_semihosting(CPUM68KState *env, int nr)
             }
         }
         break;
+#endif /* CONFIG_IOS */
     case HOSTED_INIT_SIM:
 #if defined(CONFIG_USER_ONLY)
         {
diff --git a/target/nios2/nios2-semi.c b/target/nios2/nios2-semi.c
index d7a80dd303..bfbaa00bb6 100644
--- a/target/nios2/nios2-semi.c
+++ b/target/nios2/nios2-semi.c
@@ -426,6 +426,7 @@ void do_nios2_semihosting(CPUNios2State *env)
             result = isatty(arg0);
         }
         break;
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case HOSTED_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -444,6 +445,7 @@ void do_nios2_semihosting(CPUNios2State *env)
             }
         }
         break;
+#endif
     default:
         qemu_log_mask(LOG_GUEST_ERROR, "nios2-semihosting: unsupported "
                       "semihosting syscall %d\n", nr);
diff --git a/tcg/aarch64/tcg-target.h b/tcg/aarch64/tcg-target.h
index ca214f6909..80d3b42b19 100644
--- a/tcg/aarch64/tcg-target.h
+++ b/tcg/aarch64/tcg-target.h
@@ -146,9 +146,19 @@ typedef enum {
 #define TCG_TARGET_DEFAULT_MO (0)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
+#ifdef __APPLE__
+void sys_icache_invalidate(void *start, size_t len);
+#endif
+
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
+#if defined(__APPLE__)
+    sys_icache_invalidate((char *)start, stop-start);
+#elif defined(__GNUC__)
     __builtin___clear_cache((char *)start, (char *)stop);
+#else
+#error "Missing builtin to flush instruction cache"
+#endif
 }
 
 void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
-- 
2.21.1 (Apple Git-122.3)

From 1474e37eaeaca216f00f1d3be72718571fc5f777 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 27 Mar 2019 14:47:00 -0700
Subject: [PATCH 2/4] build: Added support for building QEMU as a shared
 library

---
 Makefile        | 21 +++++++++++++++++++++
 Makefile.target | 24 +++++++++++++++++++++++-
 configure       | 18 +++++++++++++++++-
 qemu-img.c      |  5 +++++
 rules.mak       |  6 ++++++
 vl.c            |  2 +-
 6 files changed, 73 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index b437a346d7..1c19d6b29e 100644
--- a/Makefile
+++ b/Makefile
@@ -558,6 +558,16 @@ Makefile: $(version-obj-y)
 libqemuutil.a: $(util-obj-y) $(trace-obj-y) $(stub-obj-y)
 libvhost-user.a: $(libvhost-user-obj-y) $(util-obj-y) $(stub-obj-y)
 
+ifdef CONFIG_DARWIN
+QEMU_IMG_SHARED_LIBRARY=libqemu-img.dylib
+else
+QEMU_IMG_SHARED_LIBRARY=libqemu-img.so
+endif
+SOBJS=$(QEMU_IMG_SHARED_LIBRARY)
+ifdef CONFIG_SHARED_LIB
+all: $(SOBJS)
+endif
+
 ######################################################################
 
 COMMON_LDADDS = libqemuutil.a
@@ -565,6 +575,11 @@ COMMON_LDADDS = libqemuutil.a
 qemu-img.o: qemu-img-cmds.h
 
 qemu-img$(EXESUF): qemu-img.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+
+$(QEMU_IMG_SHARED_LIBRARY): LDFLAGS += $(LDFLAGS_SHARED)
+$(QEMU_IMG_SHARED_LIBRARY): qemu-img.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+
 qemu-nbd$(EXESUF): qemu-nbd.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-io$(EXESUF): qemu-io.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 
@@ -712,6 +727,7 @@ clean: recurse-clean
 		-exec rm {} +
 	rm -f $(edk2-decompressed)
 	rm -f $(filter-out %.tlb,$(TOOLS)) $(HELPERS-y) TAGS cscope.* *.pod *~ */*~
+	rm -f $(SOBJS)
 	rm -f fsdev/*.pod scsi/*.pod
 	rm -f qemu-img-cmds.h
 	rm -f ui/shader/*-vert.h ui/shader/*-frag.h
@@ -873,6 +889,11 @@ install: all $(if $(BUILD_DOCS),install-doc) \
 ifneq ($(TOOLS),)
 	$(call install-prog,$(TOOLS),$(DESTDIR)$(bindir))
 endif
+ifdef CONFIG_SHARED_LIB
+ifneq ($(SOBJS),)
+	$(call install-so,$(SOBJS),$(DESTDIR)$(libdir))
+endif
+endif
 ifneq ($(CONFIG_MODULES),)
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_moddir)"
 	for s in $(modules-m:.mo=$(DSOSUF)); do \
diff --git a/Makefile.target b/Makefile.target
index 24d79d26eb..ee0bedb82d 100644
--- a/Makefile.target
+++ b/Makefile.target
@@ -37,6 +37,14 @@ endif
 endif
 
 PROGS=$(QEMU_PROG) $(QEMU_PROGW)
+
+ifdef CONFIG_DARWIN
+QEMU_SHARED_LIBRARY=lib$(QEMU_PROG).dylib
+else
+QEMU_SHARED_LIBRARY=lib$(QEMU_PROG).so
+endif
+SOBJS=$(QEMU_SHARED_LIBRARY)
+
 STPFILES=
 
 config-target.h: config-target.h-timestamp
@@ -98,7 +106,11 @@ stap:
 endif
 .PHONY: stap
 
+ifdef CONFIG_SHARED_LIB
+all: $(SOBJS) stap
+else
 all: $(PROGS) stap
+endif
 
 # Dummy command so that make thinks it has done something
 	@true
@@ -211,6 +223,10 @@ ifdef CONFIG_DARWIN
 	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
 endif
 
+$(QEMU_SHARED_LIBRARY): LDFLAGS += $(LDFLAGS_SHARED)
+$(QEMU_SHARED_LIBRARY): $(all-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+
 gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
 	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"GEN","$(TARGET_DIR)$@")
 
@@ -221,7 +237,7 @@ hmp-commands-info.h: $(SRC_PATH)/hmp-commands-info.hx $(SRC_PATH)/scripts/hxtool
 	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"GEN","$(TARGET_DIR)$@")
 
 clean: clean-target
-	rm -f *.a *~ $(PROGS)
+	rm -f *.a *~ $(PROGS) $(SOBJS)
 	rm -f $(shell find . -name '*.[od]')
 	rm -f hmp-commands.h gdbstub-xml.c
 	rm -f trace/generated-helpers.c trace/generated-helpers.c-timestamp
@@ -230,9 +246,15 @@ ifdef CONFIG_TRACE_SYSTEMTAP
 endif
 
 install: all
+ifdef CONFIG_SHARED_LIB
+ifneq ($(SOBJS),)
+	$(call install-so,$(SOBJS),$(DESTDIR)$(libdir))
+endif
+else
 ifneq ($(PROGS),)
 	$(call install-prog,$(PROGS),$(DESTDIR)$(bindir))
 endif
+endif
 ifdef CONFIG_TRACE_SYSTEMTAP
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset"
 	$(INSTALL_DATA) $(QEMU_PROG).stp-installed "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG).stp"
diff --git a/configure b/configure
index 2221ba58d2..ae62e4ea61 100755
--- a/configure
+++ b/configure
@@ -505,6 +505,7 @@ libpmem=""
 default_devices="yes"
 plugins="no"
 host_device_support="yes"
+shared_lib="no"
 
 supported_cpu="no"
 supported_os="no"
@@ -859,6 +860,7 @@ Darwin)
   darwin="yes"
   hax="yes"
   hvf="yes"
+  DSOSUF=".dylib"
   LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
   if [ "$cpu" = "x86_64" ] ; then
     QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
@@ -881,7 +883,8 @@ iOS)
   ios="yes"
   hax="yes"
   hvf="yes"
-  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  DSOSUF=".dylib"
+  LDFLAGS_SHARED="-dynamiclib"
   if [ "$cpu" = "x86_64" ] ; then
     QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
     LDFLAGS="-arch x86_64 $LDFLAGS"
@@ -1578,6 +1581,14 @@ for opt do
   ;;
   --disable-plugins) plugins="no"
   ;;
+  --enable-shared-lib)
+      shared_lib=yes
+      want_tools=no
+      QEMU_CFLAGS="$QEMU_CFLAGS -fPIC"
+      DSOSUF="-module$DSOSUF" # fix for make 2.81 not building target order correctly
+  ;;
+  --disable-shared-lib) shared_lib=no
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1761,6 +1772,7 @@ Advanced options (experts only):
                            track the maximum stack usage of stacks created by qemu_alloc_stack
   --enable-plugins
                            enable plugins via shared library loading
+  --enable-shared-lib      build QEMU as a shared library instead of an application
 
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available:
@@ -6639,6 +6651,7 @@ echo "libudev           $libudev"
 echo "default devices   $default_devices"
 echo "plugin support    $plugins"
 echo "host device support  $host_device_support"
+echo "build shared lib  $shared_lib"
 
 if test "$supported_cpu" = "no"; then
     echo
@@ -6718,6 +6731,9 @@ fi
 if test "$host_device_support" = "yes" ; then
   echo "CONFIG_HOST_DEVICE=y" >> $config_host_mak
 fi
+if test "$shared_lib" = "yes" ; then
+  echo "CONFIG_SHARED_LIB=y" >> $config_host_mak
+fi
 if test "$debug_tcg" = "yes" ; then
   echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
 fi
diff --git a/qemu-img.c b/qemu-img.c
index 95a24b9762..6500d273dd 100644
--- a/qemu-img.c
+++ b/qemu-img.c
@@ -49,6 +49,11 @@
 #include "crypto/init.h"
 #include "trace/control.h"
 
+#if defined(CONFIG_SHARED_LIB)
+#undef main
+#define main qemu_img_main
+#endif
+
 #define QEMU_IMG_VERSION "qemu-img version " QEMU_FULL_VERSION \
                           "\n" QEMU_COPYRIGHT "\n"
 
diff --git a/rules.mak b/rules.mak
index 967295dd2b..9e9672f804 100644
--- a/rules.mak
+++ b/rules.mak
@@ -154,6 +154,12 @@ define install-prog
 	$(if $(STRIP),$(STRIP) $(foreach T,$1,"$2/$(notdir $T)"),)
 endef
 
+# install-so list, dir
+define install-so
+    $(INSTALL_DIR) "$2"
+    $(INSTALL_LIB) $1 "$2"
+endef
+
 # find-in-path
 # Usage: $(call find-in-path, prog)
 # Looks in the PATH if the argument contains no slash, else only considers one
diff --git a/vl.c b/vl.c
index 6a65a64bfd..3e14194825 100644
--- a/vl.c
+++ b/vl.c
@@ -49,7 +49,7 @@ int main(int argc, char **argv)
 #endif
 #endif /* CONFIG_SDL */
 
-#ifdef CONFIG_COCOA
+#if defined(CONFIG_COCOA) || defined(CONFIG_SHARED_LIB)
 #undef main
 #define main qemu_main
 #endif /* CONFIG_COCOA */
-- 
2.21.1 (Apple Git-122.3)

From 4e91fc77d5f7f0dc3a3e0dbaa08018f2a1ce9b2d Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Fri, 29 Mar 2019 15:41:07 -0700
Subject: [PATCH 3/4] coroutine: add libucontext as external library

iOS does not support ucontext natively for aarch64 and the sigaltstack is also unsupported (even worse, it fails silently, see: https://openradar.appspot.com/13002712 )
---
 .gitmodules               |  3 +++
 Makefile                  | 11 +++++++++++
 configure                 | 27 +++++++++++++++++++++++++--
 libucontext               |  1 +
 util/coroutine-ucontext.c |  9 +++++++++
 5 files changed, 49 insertions(+), 2 deletions(-)
 create mode 160000 libucontext

diff --git a/.gitmodules b/.gitmodules
index 19792c9a11..5127b48928 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -61,3 +61,6 @@
 [submodule "roms/qboot"]
 	path = roms/qboot
 	url = https://github.com/bonzini/qboot
+[submodule "libucontext"]
+	path = libucontext
+	url = https://github.com/halts/libucontext.git
diff --git a/Makefile b/Makefile
index 1c19d6b29e..b2554d8847 100644
--- a/Makefile
+++ b/Makefile
@@ -513,6 +513,9 @@ CAP_CFLAGS += -DCAPSTONE_HAS_ARM64
 CAP_CFLAGS += -DCAPSTONE_HAS_POWERPC
 CAP_CFLAGS += -DCAPSTONE_HAS_X86
 
+LIBUCONTEXT_CFLAGS = $(CFLAGS) $(QEMU_CFLAGS)
+LIBUCONTEXT_CFLAGS += -DCUSTOM_IMPL
+
 .PHONY: capstone/all
 capstone/all: .git-submodule-status
 	$(call quiet-command,$(MAKE) -C $(SRC_PATH)/capstone CAPSTONE_SHARED=no BUILDDIR="$(BUILD_DIR)/capstone" CC="$(CC)" AR="$(AR)" LD="$(LD)" RANLIB="$(RANLIB)" CFLAGS="$(CAP_CFLAGS)" $(SUBDIR_MAKEFLAGS) $(BUILD_DIR)/capstone/$(LIBCAPSTONE))
@@ -525,11 +528,19 @@ slirp/all: .git-submodule-status
 		CC="$(CC)" AR="$(AR)" 	LD="$(LD)" RANLIB="$(RANLIB)"	\
 		CFLAGS="$(QEMU_CFLAGS) $(CFLAGS)" LDFLAGS="$(LDFLAGS)")
 
+.PHONY: libucontext/all
+libucontext/all: .git-submodule-status
+	$(call quiet-command,$(MAKE) -C $(SRC_PATH)/libucontext \
+		ARCH="$(ARCH)" BUILD_DIR="$(BUILD_DIR)/libucontext" \
+		CC="$(CC)" AR="$(AR)" LD="$(LD)" RANLIB="$(RANLIB)" \
+		CFLAGS="$(LIBUCONTEXT_CFLAGS)")
+
 # Compatibility gunk to keep make working across the rename of targets
 # for recursion, to be removed some time after 4.1.
 subdir-dtc: dtc/all
 subdir-capstone: capstone/all
 subdir-slirp: slirp/all
+subdir-libucontext: libucontext/all
 
 $(filter %/all, $(TARGET_DIRS_RULES)): libqemuutil.a $(common-obj-y) \
 	$(qom-obj-y) $(crypto-user-obj-$(CONFIG_USER_ONLY))
diff --git a/configure b/configure
index ae62e4ea61..64d85ba851 100755
--- a/configure
+++ b/configure
@@ -1759,7 +1759,7 @@ Advanced options (experts only):
   --oss-lib                path to OSS library
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-gcov            enable test coverage analysis with gcov
   --gcov=GCOV              use specified gcov [$gcov_tool]
   --disable-blobs          disable installing provided firmware blobs
@@ -5341,6 +5341,8 @@ if test "$coroutine" = ""; then
     coroutine=win32
   elif test "$ucontext_works" = "yes"; then
     coroutine=ucontext
+  elif test "$ios" = "yes"; then
+    coroutine=libucontext
   else
     coroutine=sigaltstack
   fi
@@ -5364,12 +5366,29 @@ else
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} libucontext"
+  mkdir -p libucontext
+  QEMU_CFLAGS="$QEMU_CFLAGS -I\$(SRC_PATH)/libucontext/include"
+  LIBS="-L\$(BUILD_DIR)/libucontext -lucontext $LIBS"
+  ;;
+esac
+
+if test "$coroutine" == "libucontext"; then
+  coroutine_impl=ucontext
+else
+  coroutine_impl=$coroutine
+fi
+
 if test "$coroutine_pool" = ""; then
   coroutine_pool=yes
 fi
@@ -7246,7 +7265,7 @@ if test "$rbd" = "yes" ; then
   echo "RBD_LIBS=$rbd_libs" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 if test "$coroutine_pool" = "yes" ; then
   echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
 else
@@ -8040,6 +8059,10 @@ fi
 if [ "$capstone" = "git" -o "$capstone" = "internal" ]; then
   echo "config-host.h: capstone/all" >> $config_host_mak
 fi
+if [ "$coroutine" = "libucontext" ]; then
+  echo "config-host.h: subdir-libucontext" >> $config_host_mak
+  echo "CONFIG_LIBUCONTEXT=y" >> $config_host_mak
+fi
 if test -n "$LIBCAPSTONE"; then
   echo "LIBCAPSTONE=$LIBCAPSTONE" >> $config_host_mak
 fi
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index bd593e61bc..86347ad78f 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 
 #ifdef CONFIG_VALGRIND_H
-- 
2.21.1 (Apple Git-122.3)

From ccde4851e1bebdd83e22155b2545bc1510db0257 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Sun, 23 Feb 2020 22:13:35 -0800
Subject: [PATCH 4/4] tcg: implement bulletproof JIT

On iOS, we cannot allocate RWX pages without special entitlements. As a
workaround, we can a RX region and then mirror map it to a separate RX
region. Then we can write to one region and execute from the other one.

To better keep track of pointers to RW/RX memory, we mark any tcg_insn_unit
pointers as `const` if they will never be written to. We also define a new
macro `TCG_CODE_PTR_RW` that returns a pointer to RW memory. Only the
difference between the two regions is stored in the TCG context.

To ensure cache coherency, we flush the data cache in the RW mapping and
then invalidate the instruction cache in the RX mapping (where applicable).
Because data cache flush is OS defined on some architectures, we do not
provide implementations for non iOS platforms (ARM/x86).
---
 accel/tcg/cpu-exec.c         |  7 +++-
 accel/tcg/translate-all.c    | 77 ++++++++++++++++++++++++++++++++++--
 configure                    |  1 +
 docs/devel/ios.rst           | 40 +++++++++++++++++++
 include/exec/exec-all.h      |  7 ++++
 tcg/aarch64/tcg-target.h     | 13 +++++-
 tcg/aarch64/tcg-target.inc.c | 48 +++++++++++++---------
 tcg/arm/tcg-target.h         |  9 ++++-
 tcg/arm/tcg-target.inc.c     | 35 +++++++++-------
 tcg/i386/tcg-target.h        | 24 ++++++++++-
 tcg/i386/tcg-target.inc.c    | 28 ++++++-------
 tcg/mips/tcg-target.h        |  8 +++-
 tcg/mips/tcg-target.inc.c    | 62 +++++++++++++++++------------
 tcg/ppc/tcg-target.h         |  8 +++-
 tcg/ppc/tcg-target.inc.c     | 51 +++++++++++++++---------
 tcg/riscv/tcg-target.h       |  9 ++++-
 tcg/riscv/tcg-target.inc.c   | 51 +++++++++++++-----------
 tcg/s390/tcg-target.h        | 13 +++++-
 tcg/s390/tcg-target.inc.c    | 25 ++++++------
 tcg/sparc/tcg-target.h       |  8 +++-
 tcg/sparc/tcg-target.inc.c   | 29 ++++++++------
 tcg/tcg-ldst.inc.c           |  2 +-
 tcg/tcg-pool.inc.c           |  9 +++--
 tcg/tcg.c                    | 60 ++++++++++++++++++----------
 tcg/tcg.h                    | 18 +++++++--
 tcg/tci/tcg-target.h         | 13 +++++-
 tcg/tci/tcg-target.inc.c     |  8 ++--
 27 files changed, 479 insertions(+), 184 deletions(-)
 create mode 100644 docs/devel/ios.rst

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index c01f59c743..a1fef809ee 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -347,7 +347,12 @@ void tb_set_jmp_target(TranslationBlock *tb, int n, uintptr_t addr)
     if (TCG_TARGET_HAS_direct_jump) {
         uintptr_t offset = tb->jmp_target_arg[n];
         uintptr_t tc_ptr = (uintptr_t)tb->tc.ptr;
-        tb_target_set_jmp_target(tc_ptr, tc_ptr + offset, addr);
+#if defined(CONFIG_IOS_JIT)
+        uintptr_t wr_addr = tc_ptr + offset + tb->code_rw_mirror_diff;
+#else
+        uintptr_t wr_addr = tc_ptr + offset;
+#endif
+        tb_target_set_jmp_target(tc_ptr, tc_ptr + offset, addr, wr_addr);
     } else {
         tb->jmp_target_arg[n] = addr;
     }
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 9f48da9472..7301ace32a 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -58,6 +58,22 @@
 #include "sysemu/cpus.h"
 #include "sysemu/tcg.h"
 
+#if defined(CONFIG_IOS_JIT)
+#include <mach/mach.h>
+extern kern_return_t mach_vm_remap(vm_map_t target_task,
+                                   mach_vm_address_t *target_address,
+                                   mach_vm_size_t size,
+                                   mach_vm_offset_t mask,
+                                   int flags,
+                                   vm_map_t src_task,
+                                   mach_vm_address_t src_address,
+                                   boolean_t copy,
+                                   vm_prot_t *cur_protection,
+                                   vm_prot_t *max_protection,
+                                   vm_inherit_t inheritance
+                                  );
+#endif
+
 /* #define DEBUG_TB_INVALIDATE */
 /* #define DEBUG_TB_FLUSH */
 /* make various TB consistency checks */
@@ -295,10 +311,12 @@ static target_long decode_sleb128(uint8_t **pp)
 
 static int encode_search(TranslationBlock *tb, uint8_t *block)
 {
-    uint8_t *highwater = tcg_ctx->code_gen_highwater;
-    uint8_t *p = block;
+    uint8_t *highwater;
+    uint8_t *p;
     int i, j, n;
 
+    highwater = (uint8_t *)TCG_CODE_PTR_RW(tcg_ctx, tcg_ctx->code_gen_highwater);
+    p = (uint8_t *)TCG_CODE_PTR_RW(tcg_ctx, block);
     for (i = 0, n = tb->icount; i < n; ++i) {
         target_ulong prev;
 
@@ -322,7 +340,7 @@ static int encode_search(TranslationBlock *tb, uint8_t *block)
         }
     }
 
-    return p - block;
+    return p - (uint8_t *)TCG_CODE_PTR_RW(tcg_ctx, block);
 }
 
 /* The cpu state corresponding to 'searched_pc' is restored.
@@ -1030,7 +1048,11 @@ static inline void *alloc_code_gen_buffer(void)
 #else
 static inline void *alloc_code_gen_buffer(void)
 {
+#if defined(CONFIG_IOS_JIT)
+    int prot = PROT_READ | PROT_EXEC;
+#else
     int prot = PROT_WRITE | PROT_READ | PROT_EXEC;
+#endif
     int flags = MAP_PRIVATE | MAP_ANONYMOUS;
     uintptr_t start = 0;
     size_t size = tcg_ctx->code_gen_buffer_size;
@@ -1108,6 +1130,39 @@ static inline void *alloc_code_gen_buffer(void)
 }
 #endif /* USE_STATIC_CODE_GEN_BUFFER, WIN32, POSIX */
 
+#if defined(CONFIG_IOS_JIT)
+static inline void *alloc_jit_rw_mirror(void *base, size_t size)
+{
+    kern_return_t ret;
+    mach_vm_address_t mirror;
+    vm_prot_t cur_prot, max_prot;
+
+    mirror = 0;
+    ret = mach_vm_remap(mach_task_self(),
+                        &mirror,
+                        size,
+                        0,
+                        VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR,
+                        mach_task_self(),
+                        (mach_vm_address_t)base,
+                        false,
+                        &cur_prot,
+                        &max_prot,
+                        VM_INHERIT_NONE
+                       );
+    if (ret != KERN_SUCCESS) {
+        return NULL;
+    }
+
+    if (mprotect((void *)mirror, size, PROT_READ | PROT_WRITE) != 0) {
+        munmap((void *)mirror, size);
+        return NULL;
+    }
+
+    return (void *)mirror;
+}
+#endif /* CONFIG_IOS_JIT */
+
 static inline void code_gen_alloc(size_t tb_size)
 {
     tcg_ctx->code_gen_buffer_size = size_code_gen_buffer(tb_size);
@@ -1116,6 +1171,19 @@ static inline void code_gen_alloc(size_t tb_size)
         fprintf(stderr, "Could not allocate dynamic translator buffer\n");
         exit(1);
     }
+#if defined(CONFIG_IOS_JIT)
+    void *mirror;
+
+    /* For iOS JIT we need a mirror mapping for code execution */
+    mirror = alloc_jit_rw_mirror(tcg_ctx->code_gen_buffer,
+                                 tcg_ctx->code_gen_buffer_size
+                                );
+    if (mirror == NULL) {
+        fprintf(stderr, "Could not remap code buffer mirror\n");
+        exit(1);
+    }
+    tcg_ctx->code_rw_mirror_diff = mirror - tcg_ctx->code_gen_buffer;
+#endif /* CONFIG_IOS_JIT */
 }
 
 static bool tb_cmp(const void *ap, const void *bp)
@@ -1711,6 +1779,9 @@ TranslationBlock *tb_gen_code(CPUState *cpu,
         cpu_loop_exit(cpu);
     }
 
+#if defined(CONFIG_IOS_JIT)
+    tb->code_rw_mirror_diff = tcg_ctx->code_rw_mirror_diff;
+#endif
     gen_code_buf = tcg_ctx->code_gen_ptr;
     tb->tc.ptr = gen_code_buf;
     tb->pc = pc;
diff --git a/configure b/configure
index 64d85ba851..1492c3b288 100755
--- a/configure
+++ b/configure
@@ -6804,6 +6804,7 @@ fi
 
 if test "$ios" = "yes" ; then
   echo "CONFIG_IOS=y" >> $config_host_mak
+  echo "CONFIG_IOS_JIT=y" >> $config_host_mak
 fi
 
 if test "$solaris" = "yes" ; then
diff --git a/docs/devel/ios.rst b/docs/devel/ios.rst
new file mode 100644
index 0000000000..b0fda060ab
--- /dev/null
+++ b/docs/devel/ios.rst
@@ -0,0 +1,40 @@
+===========
+iOS Support
+===========
+
+To run qemu on the iOS platform, some modifications were required. Most of the 
+modifications are conditioned on the ``CONFIG_IOS`` and ``CONFIG_IOS_JIT`` 
+configuration variables.
+
+Build support
+-------------
+
+For the code to compile, certain changes in the block driver and the slirp 
+driver had to be made. There is no ``system()`` call, so code requiring it had 
+to be disabled.
+
+``ucontext`` support is broken on iOS. The implementation from ``libucontext`` 
+is used instead.
+
+Because ``fork()`` is not allowed on iOS apps, the option to build qemu and the 
+utilities as shared libraries is added. Note that because qemu does not perform 
+resource cleanup in most cases (open files, allocated memory, etc), it is 
+advisable that the user implements a proxy layer for syscalls so resources can 
+be kept track by the app that uses qemu as a shared library.
+
+JIT support
+-----------
+
+On iOS, allocating RWX pages require special entitlements not usually granted to
+apps. However, it is possible to use `bulletproof JIT`_ with a development 
+certificate. This means that we need to allocate one chunk of memory with RX 
+permissions and then mirror map the same memory with RW permissions. We generate
+code to the mirror mapping and execute the original mapping.
+
+With ``CONFIG_IOS_JIT`` defined, we store inside the TCG context the difference 
+between the two mappings. Then, we make sure that any writes to JIT memory is 
+done to the pointer + the difference (in order to get a pointer to the mirror 
+mapped space). Additionally, we make sure to flush the data cache before we 
+invalidate the instruction cache so the changes are seen in both mappings.
+
+.. _bulletproof JIT: https://www.blackhat.com/docs/us-16/materials/us-16-Krstic.pdf
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index d85e610e85..c115b78cd8 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -430,6 +430,13 @@ struct TranslationBlock {
     uintptr_t jmp_list_head;
     uintptr_t jmp_list_next[2];
     uintptr_t jmp_dest[2];
+
+#if defined(CONFIG_IOS_JIT)
+    /* Store difference to writable mirror
+     * We need this when patching the jump instructions
+     */
+    ptrdiff_t code_rw_mirror_diff;
+#endif
 };
 
 extern bool parallel_cpus;
diff --git a/tcg/aarch64/tcg-target.h b/tcg/aarch64/tcg-target.h
index 80d3b42b19..9bf041eac5 100644
--- a/tcg/aarch64/tcg-target.h
+++ b/tcg/aarch64/tcg-target.h
@@ -148,6 +148,7 @@ typedef enum {
 
 #ifdef __APPLE__
 void sys_icache_invalidate(void *start, size_t len);
+void sys_dcache_flush(void *start, size_t len);
 #endif
 
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
@@ -161,7 +162,17 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 #endif
 }
 
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#if defined(__APPLE__)
+    sys_dcache_flush((char *)start, stop-start);
+#else
+#error "Missing function to flush data cache"
+#endif
+}
+#endif
 
 #ifdef CONFIG_SOFTMMU
 #define TCG_TARGET_NEED_LDST_LABELS
diff --git a/tcg/aarch64/tcg-target.inc.c b/tcg/aarch64/tcg-target.inc.c
index 3f921015d3..725f7f4d4d 100644
--- a/tcg/aarch64/tcg-target.inc.c
+++ b/tcg/aarch64/tcg-target.inc.c
@@ -78,38 +78,44 @@ static const int tcg_target_call_oarg_regs[1] = {
 #define TCG_REG_GUEST_BASE TCG_REG_X28
 #endif
 
-static inline bool reloc_pc26(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc26(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - code_ptr;
     if (offset == sextract64(offset, 0, 26)) {
         /* read instruction, mask away previous PC_REL26 parameter contents,
            set the proper offset, then write back the instruction. */
-        *code_ptr = deposit32(*code_ptr, 0, 26, offset);
+        *TCG_CODE_PTR_RW(s, code_ptr) =
+            deposit32(*TCG_CODE_PTR_RW(s, code_ptr), 0, 26, offset);
         return true;
     }
     return false;
 }
 
-static inline bool reloc_pc19(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc19(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - code_ptr;
     if (offset == sextract64(offset, 0, 19)) {
-        *code_ptr = deposit32(*code_ptr, 5, 19, offset);
+        *TCG_CODE_PTR_RW(s, code_ptr) =
+            deposit32(*TCG_CODE_PTR_RW(s, code_ptr), 5, 19, offset);
         return true;
     }
     return false;
 }
 
-static inline bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static inline bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                                intptr_t value, intptr_t addend)
 {
     tcg_debug_assert(addend == 0);
     switch (type) {
     case R_AARCH64_JUMP26:
     case R_AARCH64_CALL26:
-        return reloc_pc26(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc26(s, code_ptr, (tcg_insn_unit *)value);
     case R_AARCH64_CONDBR19:
-        return reloc_pc19(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc19(s, code_ptr, (tcg_insn_unit *)value);
     default:
         g_assert_not_reached();
     }
@@ -1308,14 +1314,14 @@ static void tcg_out_cmp(TCGContext *s, TCGType ext, TCGReg a,
     }
 }
 
-static inline void tcg_out_goto(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_goto(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - s->code_ptr;
     tcg_debug_assert(offset == sextract64(offset, 0, 26));
     tcg_out_insn(s, 3206, B, offset);
 }
 
-static inline void tcg_out_goto_long(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_goto_long(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - s->code_ptr;
     if (offset == sextract64(offset, 0, 26)) {
@@ -1331,7 +1337,7 @@ static inline void tcg_out_callr(TCGContext *s, TCGReg reg)
     tcg_out_insn(s, 3207, BLR, reg);
 }
 
-static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = target - s->code_ptr;
     if (offset == sextract64(offset, 0, 26)) {
@@ -1343,7 +1349,7 @@ static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *target)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     tcg_insn_unit i1, i2;
     TCGType rt = TCG_TYPE_I64;
@@ -1364,7 +1370,10 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
         i2 = I3401_ADDI | rt << 31 | (addr & 0xfff) << 10 | rd << 5 | rd;
     }
     pair = (uint64_t)i2 << 32 | i1;
-    atomic_set((uint64_t *)jmp_addr, pair);
+    atomic_set((uint64_t *)wr_addr, pair);
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
     flush_icache_range(jmp_addr, jmp_addr + 8);
 }
 
@@ -1570,7 +1579,7 @@ static void * const qemu_st_helpers[16] = {
     [MO_BEQ]  = helper_be_stq_mmu,
 };
 
-static inline void tcg_out_adr(TCGContext *s, TCGReg rd, void *target)
+static inline void tcg_out_adr(TCGContext *s, TCGReg rd, const void *target)
 {
     ptrdiff_t offset = tcg_pcrel_diff(s, target);
     tcg_debug_assert(offset == sextract64(offset, 0, 21));
@@ -1583,7 +1592,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     MemOp size = opc & MO_SIZE;
 
-    if (!reloc_pc19(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc19(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1608,7 +1617,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     MemOp size = opc & MO_SIZE;
 
-    if (!reloc_pc19(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc19(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1624,7 +1633,8 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
 
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGType ext, TCGReg data_reg, TCGReg addr_reg,
-                                tcg_insn_unit *raddr, tcg_insn_unit *label_ptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1851,7 +1861,7 @@ static void tcg_out_qemu_st(TCGContext *s, TCGReg data_reg, TCGReg addr_reg,
 #endif /* CONFIG_SOFTMMU */
 }
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg args[TCG_MAX_OP_ARGS],
@@ -2870,11 +2880,11 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_insn(s, 3207, RET, TCG_REG_LR);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = NOP;
     }
 }
 
diff --git a/tcg/arm/tcg-target.h b/tcg/arm/tcg-target.h
index 17e771374d..d8d7e7e239 100644
--- a/tcg/arm/tcg-target.h
+++ b/tcg/arm/tcg-target.h
@@ -139,8 +139,15 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     __builtin___clear_cache((char *) start, (char *) stop);
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 /* not defined -- call should be eliminated at compile time */
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
 #ifdef CONFIG_SOFTMMU
 #define TCG_TARGET_NEED_LDST_LABELS
diff --git a/tcg/arm/tcg-target.inc.c b/tcg/arm/tcg-target.inc.c
index 94d80d79d1..4a6202b96f 100644
--- a/tcg/arm/tcg-target.inc.c
+++ b/tcg/arm/tcg-target.inc.c
@@ -187,17 +187,22 @@ static const uint8_t tcg_cond_to_arm_cond[] = {
     [TCG_COND_GTU] = COND_HI,
 };
 
-static inline bool reloc_pc24(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc24(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = (tcg_ptr_byte_diff(target, code_ptr) - 8) >> 2;
     if (offset == sextract32(offset, 0, 24)) {
-        *code_ptr = (*code_ptr & ~0xffffff) | (offset & 0xffffff);
+        *TCG_CODE_PTR_RW(s, code_ptr) = 
+            (*TCG_CODE_PTR_RW(s, code_ptr) & ~0xffffff) | (offset & 0xffffff);
         return true;
     }
     return false;
 }
 
-static inline bool reloc_pc13(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static inline bool reloc_pc13(TCGContext *s,
+                              tcg_insn_unit *code_ptr,
+                              const tcg_insn_unit *target)
 {
     ptrdiff_t offset = tcg_ptr_byte_diff(target, code_ptr) - 8;
 
@@ -209,21 +214,21 @@ static inline bool reloc_pc13(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
         }
         insn = deposit32(insn, 23, 1, u);
         insn = deposit32(insn, 0, 12, offset);
-        *code_ptr = insn;
+        *TCG_CODE_PTR_RW(s, code_ptr) = insn;
         return true;
     }
     return false;
 }
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     tcg_debug_assert(addend == 0);
 
     if (type == R_ARM_PC24) {
-        return reloc_pc24(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc24(s, code_ptr, (tcg_insn_unit *)value);
     } else if (type == R_ARM_PC13) {
-        return reloc_pc13(code_ptr, (tcg_insn_unit *)value);
+        return reloc_pc13(s, code_ptr, (tcg_insn_unit *)value);
     } else {
         g_assert_not_reached();
     }
@@ -1022,7 +1027,7 @@ static inline void tcg_out_st8(TCGContext *s, int cond,
  * with the code buffer limited to 16MB we wouldn't need the long case.
  * But we also use it for the tail-call to the qemu_ld/st helpers, which does.
  */
-static void tcg_out_goto(TCGContext *s, int cond, tcg_insn_unit *addr)
+static void tcg_out_goto(TCGContext *s, int cond, const tcg_insn_unit *addr)
 {
     intptr_t addri = (intptr_t)addr;
     ptrdiff_t disp = tcg_pcrel_diff(s, addr);
@@ -1036,7 +1041,7 @@ static void tcg_out_goto(TCGContext *s, int cond, tcg_insn_unit *addr)
 
 /* The call case is mostly used for helpers - so it's not unreasonable
  * for them to be beyond branch range */
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *addr)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *addr)
 {
     intptr_t addri = (intptr_t)addr;
     ptrdiff_t disp = tcg_pcrel_diff(s, addr);
@@ -1329,7 +1334,7 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,
    helper code.  */
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGReg datalo, TCGReg datahi, TCGReg addrlo,
-                                TCGReg addrhi, tcg_insn_unit *raddr,
+                                TCGReg addrhi, const tcg_insn_unit *raddr,
                                 tcg_insn_unit *label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
@@ -1351,7 +1356,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     void *func;
 
-    if (!reloc_pc24(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc24(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1414,7 +1419,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     TCGMemOpIdx oi = lb->oi;
     MemOp opc = get_memop(oi);
 
-    if (!reloc_pc24(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc24(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -1745,7 +1750,7 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
 #endif
 }
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
                 const TCGArg *args, const int *const_args)
@@ -2264,11 +2269,11 @@ static inline void tcg_out_movi(TCGContext *s, TCGType type,
     tcg_out_movi32(s, COND_AL, ret, arg);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = INSN_NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = INSN_NOP;
     }
 }
 
diff --git a/tcg/i386/tcg-target.h b/tcg/i386/tcg-target.h
index 928e8b87bb..14fa486d4a 100644
--- a/tcg/i386/tcg-target.h
+++ b/tcg/i386/tcg-target.h
@@ -204,16 +204,36 @@ extern bool have_avx2;
 #define TCG_TARGET_extract_i64_valid(ofs, len) \
     (((ofs) == 8 && (len) == 8) || ((ofs) + (len)) == 32)
 
+#ifdef __APPLE__
+void sys_dcache_flush(void *start, size_t len);
+#endif
+
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#if defined(__APPLE__)
+    //sys_dcache_flush((char *)start, stop-start);
+#else
+#error "Missing function to flush data cache"
+#endif
+}
+#endif
+
 static inline void tb_target_set_jmp_target(uintptr_t tc_ptr,
-                                            uintptr_t jmp_addr, uintptr_t addr)
+                                            uintptr_t jmp_addr, uintptr_t addr,
+                                            uintptr_t wr_addr)
 {
     /* patch the branch destination */
-    atomic_set((int32_t *)jmp_addr, addr - (jmp_addr + 4));
+    atomic_set((int32_t *)wr_addr, addr - (jmp_addr + 4));
     /* no need to flush icache explicitly */
+#if defined(CONFIG_IOS_JIT)
+    /* we do need to flush mirror dcache */
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
 }
 
 /* This defines the natural memory order supported by this
diff --git a/tcg/i386/tcg-target.inc.c b/tcg/i386/tcg-target.inc.c
index 9d8ed974e0..ab3b3458dd 100644
--- a/tcg/i386/tcg-target.inc.c
+++ b/tcg/i386/tcg-target.inc.c
@@ -165,9 +165,9 @@ static bool have_lzcnt;
 # define have_lzcnt 0
 #endif
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     value += addend;
@@ -179,14 +179,14 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         }
         /* FALLTHRU */
     case R_386_32:
-        tcg_patch32(code_ptr, value);
+        tcg_patch32(s, code_ptr, value);
         break;
     case R_386_PC8:
         value -= (uintptr_t)code_ptr;
         if (value != (int8_t)value) {
             return false;
         }
-        tcg_patch8(code_ptr, value);
+        tcg_patch8(s, code_ptr, value);
         break;
     default:
         tcg_abort();
@@ -1602,7 +1602,7 @@ static void tcg_out_clz(TCGContext *s, int rexw, TCGReg dest, TCGReg arg1,
     }
 }
 
-static void tcg_out_branch(TCGContext *s, int call, tcg_insn_unit *dest)
+static void tcg_out_branch(TCGContext *s, int call, const tcg_insn_unit *dest)
 {
     intptr_t disp = tcg_pcrel_diff(s, dest) - 5;
 
@@ -1621,12 +1621,12 @@ static void tcg_out_branch(TCGContext *s, int call, tcg_insn_unit *dest)
     }
 }
 
-static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *dest)
 {
     tcg_out_branch(s, 1, dest);
 }
 
-static void tcg_out_jmp(TCGContext *s, tcg_insn_unit *dest)
+static void tcg_out_jmp(TCGContext *s, const tcg_insn_unit *dest)
 {
     tcg_out_branch(s, 0, dest);
 }
@@ -1785,7 +1785,7 @@ static void add_qemu_ldst_label(TCGContext *s, bool is_ld, bool is_64,
                                 TCGMemOpIdx oi,
                                 TCGReg datalo, TCGReg datahi,
                                 TCGReg addrlo, TCGReg addrhi,
-                                tcg_insn_unit *raddr,
+                                const tcg_insn_unit *raddr,
                                 tcg_insn_unit **label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
@@ -1816,9 +1816,9 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     int rexw = (l->type == TCG_TYPE_I64 ? P_REXW : 0);
 
     /* resolve label address */
-    tcg_patch32(label_ptr[0], s->code_ptr - label_ptr[0] - 4);
+    tcg_patch32(s, label_ptr[0], s->code_ptr - label_ptr[0] - 4);
     if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
-        tcg_patch32(label_ptr[1], s->code_ptr - label_ptr[1] - 4);
+        tcg_patch32(s, label_ptr[1], s->code_ptr - label_ptr[1] - 4);
     }
 
     if (TCG_TARGET_REG_BITS == 32) {
@@ -1901,9 +1901,9 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     TCGReg retaddr;
 
     /* resolve label address */
-    tcg_patch32(label_ptr[0], s->code_ptr - label_ptr[0] - 4);
+    tcg_patch32(s, label_ptr[0], s->code_ptr - label_ptr[0] - 4);
     if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
-        tcg_patch32(label_ptr[1], s->code_ptr - label_ptr[1] - 4);
+        tcg_patch32(s, label_ptr[1], s->code_ptr - label_ptr[1] - 4);
     }
 
     if (TCG_TARGET_REG_BITS == 32) {
@@ -3762,9 +3762,9 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_opc(s, OPC_RET, 0, 0, 0);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
-    memset(p, 0x90, count);
+    memset(TCG_CODE_PTR_RW(s, p), 0x90, count);
 }
 
 static void tcg_target_init(TCGContext *s)
diff --git a/tcg/mips/tcg-target.h b/tcg/mips/tcg-target.h
index c6b091d849..80dcba5358 100644
--- a/tcg/mips/tcg-target.h
+++ b/tcg/mips/tcg-target.h
@@ -212,7 +212,13 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     cacheflush ((void *)start, stop-start, ICACHE);
 }
 
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
 
 #ifdef CONFIG_SOFTMMU
 #define TCG_TARGET_NEED_LDST_LABELS
diff --git a/tcg/mips/tcg-target.inc.c b/tcg/mips/tcg-target.inc.c
index 5442167045..56992ad94f 100644
--- a/tcg/mips/tcg-target.inc.c
+++ b/tcg/mips/tcg-target.inc.c
@@ -139,12 +139,13 @@ static const TCGReg tcg_target_call_oarg_regs[2] = {
     TCG_REG_V1
 };
 
-static tcg_insn_unit *tb_ret_addr;
-static tcg_insn_unit *bswap32_addr;
-static tcg_insn_unit *bswap32u_addr;
-static tcg_insn_unit *bswap64_addr;
+static const tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *bswap32_addr;
+static const tcg_insn_unit *bswap32u_addr;
+static const tcg_insn_unit *bswap64_addr;
 
-static inline uint32_t reloc_pc16_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline uint32_t reloc_pc16_val(const tcg_insn_unit *pc,
+                                      const tcg_insn_unit *target)
 {
     /* Let the compiler perform the right-shift as part of the arithmetic.  */
     ptrdiff_t disp = target - (pc + 1);
@@ -152,28 +153,35 @@ static inline uint32_t reloc_pc16_val(tcg_insn_unit *pc, tcg_insn_unit *target)
     return disp & 0xffff;
 }
 
-static inline void reloc_pc16(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline void reloc_pc16(TCGContext *s,
+                              tcg_insn_unit *pc,
+                              const tcg_insn_unit *target)
 {
-    *pc = deposit32(*pc, 0, 16, reloc_pc16_val(pc, target));
+    *TCG_CODE_PTR_RW(s, pc) =
+        deposit32(*TCG_CODE_PTR_RW(s, pc), 0, 16, reloc_pc16_val(pc, target));
 }
 
-static inline uint32_t reloc_26_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline uint32_t reloc_26_val(const tcg_insn_unit *pc,
+                                    const tcg_insn_unit *target)
 {
     tcg_debug_assert((((uintptr_t)pc ^ (uintptr_t)target) & 0xf0000000) == 0);
     return ((uintptr_t)target >> 2) & 0x3ffffff;
 }
 
-static inline void reloc_26(tcg_insn_unit *pc, tcg_insn_unit *target)
+static inline void reloc_26(TCGContext *s,
+                            tcg_insn_unit *pc,
+                            const tcg_insn_unit *target)
 {
-    *pc = deposit32(*pc, 0, 26, reloc_26_val(pc, target));
+    *TCG_CODE_PTR_RW(s, pc) =
+        deposit32(*TCG_CODE_PTR_RW(s, pc), 0, 26, reloc_26_val(pc, target));
 }
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     tcg_debug_assert(type == R_MIPS_PC16);
     tcg_debug_assert(addend == 0);
-    reloc_pc16(code_ptr, (tcg_insn_unit *)value);
+    reloc_pc16(s, code_ptr, (tcg_insn_unit *)value);
     return true;
 }
 
@@ -519,7 +527,7 @@ static void tcg_out_opc_sa64(TCGContext *s, MIPSInsn opc1, MIPSInsn opc2,
  * Type jump.
  * Returns true if the branch was in range and the insn was emitted.
  */
-static bool tcg_out_opc_jmp(TCGContext *s, MIPSInsn opc, void *target)
+static bool tcg_out_opc_jmp(TCGContext *s, MIPSInsn opc, const void *target)
 {
     uintptr_t dest = (uintptr_t)target;
     uintptr_t from = (uintptr_t)s->code_ptr + 4;
@@ -634,7 +642,7 @@ static inline void tcg_out_bswap16s(TCGContext *s, TCGReg ret, TCGReg arg)
     }
 }
 
-static void tcg_out_bswap_subr(TCGContext *s, tcg_insn_unit *sub)
+static void tcg_out_bswap_subr(TCGContext *s, const tcg_insn_unit *sub)
 {
     bool ok = tcg_out_opc_jmp(s, OPC_JAL, sub);
     tcg_debug_assert(ok);
@@ -928,7 +936,7 @@ static void tcg_out_brcond(TCGContext *s, TCGCond cond, TCGReg arg1,
 
     tcg_out_opc_br(s, b_opc, arg1, arg2);
     if (l->has_value) {
-        reloc_pc16(s->code_ptr - 1, l->u.value_ptr);
+        reloc_pc16(s, s->code_ptr - 1, l->u.value_ptr);
     } else {
         tcg_out_reloc(s, s->code_ptr - 1, R_MIPS_PC16, l, 0);
     }
@@ -1082,7 +1090,7 @@ static void tcg_out_movcond(TCGContext *s, TCGCond cond, TCGReg ret,
     }
 }
 
-static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
+static void tcg_out_call_int(TCGContext *s, const tcg_insn_unit *arg, bool tail)
 {
     /* Note that the ABI requires the called function's address to be
        loaded into T9, even if a direct branch is in range.  */
@@ -1100,7 +1108,7 @@ static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *arg)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
     tcg_out_call_int(s, arg, false);
     tcg_out_nop(s);
@@ -1292,7 +1300,8 @@ static void add_qemu_ldst_label(TCGContext *s, int is_ld, TCGMemOpIdx oi,
                                 TCGType ext,
                                 TCGReg datalo, TCGReg datahi,
                                 TCGReg addrlo, TCGReg addrhi,
-                                void *raddr, tcg_insn_unit *label_ptr[2])
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *label_ptr[2])
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1318,9 +1327,9 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     int i;
 
     /* resolve label address */
-    reloc_pc16(l->label_ptr[0], s->code_ptr);
+    reloc_pc16(s, l->label_ptr[0], s->code_ptr);
     if (TCG_TARGET_REG_BITS < TARGET_LONG_BITS) {
-        reloc_pc16(l->label_ptr[1], s->code_ptr);
+        reloc_pc16(s, l->label_ptr[1], s->code_ptr);
     }
 
     i = 1;
@@ -1348,7 +1357,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     }
 
     tcg_out_opc_br(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO);
-    reloc_pc16(s->code_ptr - 1, l->raddr);
+    reloc_pc16(s, s->code_ptr - 1, l->raddr);
 
     /* delay slot */
     if (TCG_TARGET_REG_BITS == 64 && l->type == TCG_TYPE_I32) {
@@ -1368,9 +1377,9 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     int i;
 
     /* resolve label address */
-    reloc_pc16(l->label_ptr[0], s->code_ptr);
+    reloc_pc16(s, l->label_ptr[0], s->code_ptr);
     if (TCG_TARGET_REG_BITS < TARGET_LONG_BITS) {
-        reloc_pc16(l->label_ptr[1], s->code_ptr);
+        reloc_pc16(s, l->label_ptr[1], s->code_ptr);
     }
 
     i = 1;
@@ -2433,7 +2442,7 @@ static void tcg_target_detect_isa(void)
     sigaction(SIGILL, &sa_old, NULL);
 }
 
-static tcg_insn_unit *align_code_ptr(TCGContext *s)
+static const tcg_insn_unit *align_code_ptr(TCGContext *s)
 {
     uintptr_t p = (uintptr_t)s->code_ptr;
     if (p & 15) {
@@ -2660,9 +2669,12 @@ static void tcg_target_init(TCGContext *s)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     atomic_set((uint32_t *)jmp_addr, deposit32(OPC_J, 0, 26, addr >> 2));
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
     flush_icache_range(jmp_addr, jmp_addr + 4);
 }
 
diff --git a/tcg/ppc/tcg-target.h b/tcg/ppc/tcg-target.h
index 4fa21f0e71..cdce0e4f59 100644
--- a/tcg/ppc/tcg-target.h
+++ b/tcg/ppc/tcg-target.h
@@ -172,7 +172,13 @@ extern bool have_vsx;
 #define TCG_TARGET_HAS_cmpsel_vec       0
 
 void flush_icache_range(uintptr_t start, uintptr_t stop);
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
 
 #define TCG_TARGET_DEFAULT_MO (0)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
diff --git a/tcg/ppc/tcg-target.inc.c b/tcg/ppc/tcg-target.inc.c
index d308d69aba..c971ad4854 100644
--- a/tcg/ppc/tcg-target.inc.c
+++ b/tcg/ppc/tcg-target.inc.c
@@ -62,7 +62,7 @@
 #define TCG_CT_CONST_MONE 0x2000
 #define TCG_CT_CONST_WSZ  0x4000
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 TCGPowerISA have_isa;
 static bool have_isel;
@@ -184,35 +184,43 @@ static inline bool in_range_b(tcg_target_long target)
     return target == sextract64(target, 0, 26);
 }
 
-static uint32_t reloc_pc24_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static uint32_t reloc_pc24_val(const tcg_insn_unit *pc,
+                               const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     tcg_debug_assert(in_range_b(disp));
     return disp & 0x3fffffc;
 }
 
-static bool reloc_pc24(tcg_insn_unit *pc, tcg_insn_unit *target)
+static bool reloc_pc24(TCGContext *s,
+                       tcg_insn_unit *pc,
+                       const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     if (in_range_b(disp)) {
-        *pc = (*pc & ~0x3fffffc) | (disp & 0x3fffffc);
+        *TCG_CODE_PTR_RW(s, pc) =
+            (*TCG_CODE_PTR_RW(s, pc) & ~0x3fffffc) | (disp & 0x3fffffc);
         return true;
     }
     return false;
 }
 
-static uint16_t reloc_pc14_val(tcg_insn_unit *pc, tcg_insn_unit *target)
+static uint16_t reloc_pc14_val(const tcg_insn_unit *pc,
+                               const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     tcg_debug_assert(disp == (int16_t) disp);
     return disp & 0xfffc;
 }
 
-static bool reloc_pc14(tcg_insn_unit *pc, tcg_insn_unit *target)
+static bool reloc_pc14(TCGContext *s,
+                       tcg_insn_unit *pc,
+                       const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_ptr_byte_diff(target, pc);
     if (disp == (int16_t) disp) {
-        *pc = (*pc & ~0xfffc) | (disp & 0xfffc);
+        *TCG_CODE_PTR_RW(s, pc) =
+            (*TCG_CODE_PTR_RW(s, pc) & ~0xfffc) | (disp & 0xfffc);
         return true;
     }
     return false;
@@ -674,7 +682,7 @@ static const uint32_t tcg_to_isel[] = {
     [TCG_COND_GTU] = ISEL | BC_(7, CR_GT),
 };
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     tcg_insn_unit *target;
@@ -686,9 +694,9 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
 
     switch (type) {
     case R_PPC_REL14:
-        return reloc_pc14(code_ptr, target);
+        return reloc_pc14(s, code_ptr, target);
     case R_PPC_REL24:
-        return reloc_pc24(code_ptr, target);
+        return reloc_pc24(s, code_ptr, target);
     case R_PPC_ADDR16:
         /*
          * We are (slightly) abusing this relocation type.  In particular,
@@ -1110,7 +1118,7 @@ static void tcg_out_xori32(TCGContext *s, TCGReg dst, TCGReg src, uint32_t c)
     tcg_out_zori32(s, dst, src, c, XORI, XORIS);
 }
 
-static void tcg_out_b(TCGContext *s, int mask, tcg_insn_unit *target)
+static void tcg_out_b(TCGContext *s, int mask, const tcg_insn_unit *target)
 {
     ptrdiff_t disp = tcg_pcrel_diff(s, target);
     if (in_range_b(disp)) {
@@ -1727,7 +1735,7 @@ static void tcg_out_mb(TCGContext *s, TCGArg a0)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     if (TCG_TARGET_REG_BITS == 64) {
         tcg_insn_unit i1, i2;
@@ -1757,16 +1765,22 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
         /* As per the enclosing if, this is ppc64.  Avoid the _Static_assert
            within atomic_set that would fail to build a ppc32 host.  */
         atomic_set__nocheck((uint64_t *)jmp_addr, pair);
+#if defined(CONFIG_IOS_JIT)
+        flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
         flush_icache_range(jmp_addr, jmp_addr + 8);
     } else {
         intptr_t diff = addr - jmp_addr;
         tcg_debug_assert(in_range_b(diff));
         atomic_set((uint32_t *)jmp_addr, B | (diff & 0x3fffffc));
+#if defined(CONFIG_IOS_JIT)
+        flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
         flush_icache_range(jmp_addr, jmp_addr + 4);
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *target)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *target)
 {
 #ifdef _CALL_AIX
     /* Look through the descriptor.  If the branch is in range, and we
@@ -1991,7 +2005,8 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, MemOp opc,
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGReg datalo_reg, TCGReg datahi_reg,
                                 TCGReg addrlo_reg, TCGReg addrhi_reg,
-                                tcg_insn_unit *raddr, tcg_insn_unit *lptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *lptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -2011,7 +2026,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp opc = get_memop(oi);
     TCGReg hi, lo, arg = TCG_REG_R3;
 
-    if (!reloc_pc14(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc14(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -2059,7 +2074,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     MemOp s_bits = opc & MO_SIZE;
     TCGReg hi, lo, arg = TCG_REG_R3;
 
-    if (!reloc_pc14(lb->label_ptr[0], s->code_ptr)) {
+    if (!reloc_pc14(s, lb->label_ptr[0], s->code_ptr)) {
         return false;
     }
 
@@ -2256,11 +2271,11 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
 #endif
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = NOP;
     }
 }
 
diff --git a/tcg/riscv/tcg-target.h b/tcg/riscv/tcg-target.h
index 032439d806..d42b361991 100644
--- a/tcg/riscv/tcg-target.h
+++ b/tcg/riscv/tcg-target.h
@@ -164,8 +164,15 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     __builtin___clear_cache((char *)start, (char *)stop);
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 /* not defined -- call should be eliminated at compile time */
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
 #define TCG_TARGET_DEFAULT_MO (0)
 
diff --git a/tcg/riscv/tcg-target.inc.c b/tcg/riscv/tcg-target.inc.c
index 7018509693..a087b93155 100644
--- a/tcg/riscv/tcg-target.inc.c
+++ b/tcg/riscv/tcg-target.inc.c
@@ -415,11 +415,11 @@ static void tcg_out_opc_jump(TCGContext *s, RISCVInsn opc,
     tcg_out32(s, encode_uj(opc, rd, imm));
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = encode_i(OPC_ADDI, TCG_REG_ZERO, TCG_REG_ZERO, 0);
+        (TCG_CODE_PTR_RW(s, p))[i] = encode_i(OPC_ADDI, TCG_REG_ZERO, TCG_REG_ZERO, 0);
     }
 }
 
@@ -427,46 +427,52 @@ static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
  * Relocations
  */
 
-static bool reloc_sbimm12(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static bool reloc_sbimm12(TCGContext *s,
+                          tcg_insn_unit *code_ptr,
+                          const tcg_insn_unit *target)
 {
     intptr_t offset = (intptr_t)target - (intptr_t)code_ptr;
 
     if (offset == sextreg(offset, 1, 12) << 1) {
-        code_ptr[0] |= encode_sbimm12(offset);
+        (TCG_CODE_PTR_RW(s, code_ptr))[0] |= encode_sbimm12(offset);
         return true;
     }
 
     return false;
 }
 
-static bool reloc_jimm20(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static bool reloc_jimm20(TCGContext *s,
+                         tcg_insn_unit *code_ptr,
+                         const tcg_insn_unit *target)
 {
     intptr_t offset = (intptr_t)target - (intptr_t)code_ptr;
 
     if (offset == sextreg(offset, 1, 20) << 1) {
-        code_ptr[0] |= encode_ujimm20(offset);
+        (TCG_CODE_PTR_RW(s, code_ptr))[0] |= encode_ujimm20(offset);
         return true;
     }
 
     return false;
 }
 
-static bool reloc_call(tcg_insn_unit *code_ptr, tcg_insn_unit *target)
+static bool reloc_call(TCGContext *s,
+                       tcg_insn_unit *code_ptr,
+                       const tcg_insn_unit *target)
 {
     intptr_t offset = (intptr_t)target - (intptr_t)code_ptr;
     int32_t lo = sextreg(offset, 0, 12);
     int32_t hi = offset - lo;
 
     if (offset == hi + lo) {
-        code_ptr[0] |= encode_uimm20(hi);
-        code_ptr[1] |= encode_imm12(lo);
+        (TCG_CODE_PTR_RW(s, code_ptr))[0] |= encode_uimm20(hi);
+        (TCG_CODE_PTR_RW(s, code_ptr))[1] |= encode_imm12(lo);
         return true;
     }
 
     return false;
 }
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     uint32_t insn = *code_ptr;
@@ -480,7 +486,7 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         diff = value - (uintptr_t)code_ptr;
         short_jmp = diff == sextreg(diff, 0, 12);
         if (short_jmp) {
-            return reloc_sbimm12(code_ptr, (tcg_insn_unit *)value);
+            return reloc_sbimm12(s, code_ptr, (tcg_insn_unit *)value);
         } else {
             /* Invert the condition */
             insn = insn ^ (1 << 12);
@@ -501,10 +507,10 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         }
         break;
     case R_RISCV_JAL:
-        return reloc_jimm20(code_ptr, (tcg_insn_unit *)value);
+        return reloc_jimm20(s, code_ptr, (tcg_insn_unit *)value);
         break;
     case R_RISCV_CALL:
-        return reloc_call(code_ptr, (tcg_insn_unit *)value);
+        return reloc_call(s, code_ptr, (tcg_insn_unit *)value);
         break;
     default:
         tcg_abort();
@@ -561,7 +567,7 @@ static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg rd,
     if (tmp == (int32_t)tmp) {
         tcg_out_opc_upper(s, OPC_AUIPC, rd, 0);
         tcg_out_opc_imm(s, OPC_ADDI, rd, rd, 0);
-        ret = reloc_call(s->code_ptr - 2, (tcg_insn_unit *)val);
+        ret = reloc_call(s, s->code_ptr - 2, (tcg_insn_unit *)val);
         tcg_debug_assert(ret == true);
         return;
     }
@@ -858,14 +864,14 @@ static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
     g_assert_not_reached();
 }
 
-static inline void tcg_out_goto(TCGContext *s, tcg_insn_unit *target)
+static inline void tcg_out_goto(TCGContext *s, const tcg_insn_unit *target)
 {
     ptrdiff_t offset = tcg_pcrel_diff(s, target);
     tcg_debug_assert(offset == sextreg(offset, 1, 20) << 1);
     tcg_out_opc_jump(s, OPC_JAL, TCG_REG_ZERO, offset);
 }
 
-static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
+static void tcg_out_call_int(TCGContext *s, const tcg_insn_unit *arg, bool tail)
 {
     TCGReg link = tail ? TCG_REG_ZERO : TCG_REG_RA;
     ptrdiff_t offset = tcg_pcrel_diff(s, arg);
@@ -879,7 +885,7 @@ static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
         /* long jump: -2147483646 to 2147483648 */
         tcg_out_opc_upper(s, OPC_AUIPC, TCG_REG_TMP0, 0);
         tcg_out_opc_imm(s, OPC_JALR, link, TCG_REG_TMP0, 0);
-        ret = reloc_call(s->code_ptr - 2, arg);\
+        ret = reloc_call(s, s->code_ptr - 2, arg);\
         tcg_debug_assert(ret == true);
     } else if (TCG_TARGET_REG_BITS == 64) {
         /* far jump: 64-bit */
@@ -892,7 +898,7 @@ static void tcg_out_call_int(TCGContext *s, tcg_insn_unit *arg, bool tail)
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *arg)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
     tcg_out_call_int(s, arg, false);
 }
@@ -1026,7 +1032,8 @@ static void add_qemu_ldst_label(TCGContext *s, int is_ld, TCGMemOpIdx oi,
                                 TCGType ext,
                                 TCGReg datalo, TCGReg datahi,
                                 TCGReg addrlo, TCGReg addrhi,
-                                void *raddr, tcg_insn_unit **label_ptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit **label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1056,7 +1063,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     }
 
     /* resolve label address */
-    if (!patch_reloc(l->label_ptr[0], R_RISCV_BRANCH,
+    if (!patch_reloc(s, l->label_ptr[0], R_RISCV_BRANCH,
                      (intptr_t) s->code_ptr, 0)) {
         return false;
     }
@@ -1091,7 +1098,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)
     }
 
     /* resolve label address */
-    if (!patch_reloc(l->label_ptr[0], R_RISCV_BRANCH,
+    if (!patch_reloc(s, l->label_ptr[0], R_RISCV_BRANCH,
                      (intptr_t) s->code_ptr, 0)) {
         return false;
     }
@@ -1278,7 +1285,7 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
 #endif
 }
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg *args, const int *const_args)
diff --git a/tcg/s390/tcg-target.h b/tcg/s390/tcg-target.h
index 07accabbd1..6fe4496e20 100644
--- a/tcg/s390/tcg-target.h
+++ b/tcg/s390/tcg-target.h
@@ -149,13 +149,24 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 static inline void tb_target_set_jmp_target(uintptr_t tc_ptr,
-                                            uintptr_t jmp_addr, uintptr_t addr)
+                                            uintptr_t jmp_addr, uintptr_t addr,
+                                            uintptr_t wr_addr)
 {
     /* patch the branch destination */
     intptr_t disp = addr - (jmp_addr - 2);
     atomic_set((int32_t *)jmp_addr, disp / 2);
     /* no need to flush icache explicitly */
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
 }
 
 #ifdef CONFIG_SOFTMMU
diff --git a/tcg/s390/tcg-target.inc.c b/tcg/s390/tcg-target.inc.c
index 8aaa4cebe8..9755369b78 100644
--- a/tcg/s390/tcg-target.inc.c
+++ b/tcg/s390/tcg-target.inc.c
@@ -363,10 +363,10 @@ static void * const qemu_st_helpers[16] = {
 };
 #endif
 
-static tcg_insn_unit *tb_ret_addr;
+static const tcg_insn_unit *tb_ret_addr;
 uint64_t s390_facilities;
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     intptr_t pcrel2;
@@ -378,13 +378,13 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
     switch (type) {
     case R_390_PC16DBL:
         if (pcrel2 == (int16_t)pcrel2) {
-            tcg_patch16(code_ptr, pcrel2);
+            tcg_patch16(s, code_ptr, pcrel2);
             return true;
         }
         break;
     case R_390_PC32DBL:
         if (pcrel2 == (int32_t)pcrel2) {
-            tcg_patch32(code_ptr, pcrel2);
+            tcg_patch32(s, code_ptr, pcrel2);
             return true;
         }
         break;
@@ -392,7 +392,7 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
         if (value == sextract64(value, 0, 20)) {
             old = *(uint32_t *)code_ptr & 0xf00000ff;
             old |= ((value & 0xfff) << 16) | ((value & 0xff000) >> 4);
-            tcg_patch32(code_ptr, old);
+            tcg_patch32(s, code_ptr, old);
             return true;
         }
         break;
@@ -1306,7 +1306,7 @@ static void tgen_extract(TCGContext *s, TCGReg dest, TCGReg src,
     tcg_out_risbg(s, dest, src, 64 - len, 63, 64 - ofs, 1);
 }
 
-static void tgen_gotoi(TCGContext *s, int cc, tcg_insn_unit *dest)
+static void tgen_gotoi(TCGContext *s, int cc, const tcg_insn_unit *dest)
 {
     ptrdiff_t off = dest - s->code_ptr;
     if (off == (int16_t)off) {
@@ -1419,7 +1419,7 @@ static void tgen_brcond(TCGContext *s, TCGType type, TCGCond c,
     tgen_branch(s, cc, l);
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *dest)
 {
     ptrdiff_t off = dest - s->code_ptr;
     if (off == (int32_t)off) {
@@ -1597,7 +1597,8 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, TCGReg addr_reg, MemOp opc,
 
 static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
                                 TCGReg data, TCGReg addr,
-                                tcg_insn_unit *raddr, tcg_insn_unit *label_ptr)
+                                const tcg_insn_unit *raddr,
+                                tcg_insn_unit *label_ptr)
 {
     TCGLabelQemuLdst *label = new_ldst_label(s);
 
@@ -1616,7 +1617,7 @@ static bool tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     TCGMemOpIdx oi = lb->oi;
     MemOp opc = get_memop(oi);
 
-    if (!patch_reloc(lb->label_ptr[0], R_390_PC16DBL,
+    if (!patch_reloc(s, lb->label_ptr[0], R_390_PC16DBL,
                      (intptr_t)s->code_ptr, 2)) {
         return false;
     }
@@ -1641,7 +1642,7 @@ static bool tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
     TCGMemOpIdx oi = lb->oi;
     MemOp opc = get_memop(oi);
 
-    if (!patch_reloc(lb->label_ptr[0], R_390_PC16DBL,
+    if (!patch_reloc(s, lb->label_ptr[0], R_390_PC16DBL,
                      (intptr_t)s->code_ptr, 2)) {
         return false;
     }
@@ -2579,9 +2580,9 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_insn(s, RR, BCR, S390_CC_ALWAYS, TCG_REG_R14);
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
-    memset(p, 0x07, count * sizeof(tcg_insn_unit));
+    memset(TCG_CODE_PTR_RW(s, p), 0x07, count * sizeof(tcg_insn_unit));
 }
 
 typedef struct {
diff --git a/tcg/sparc/tcg-target.h b/tcg/sparc/tcg-target.h
index 633841ebf2..d102e13692 100644
--- a/tcg/sparc/tcg-target.h
+++ b/tcg/sparc/tcg-target.h
@@ -176,7 +176,13 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
     }
 }
 
-void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
 
 #define TCG_TARGET_NEED_POOL_LABELS
 
diff --git a/tcg/sparc/tcg-target.inc.c b/tcg/sparc/tcg-target.inc.c
index d7986cda5c..ec9c7bbea8 100644
--- a/tcg/sparc/tcg-target.inc.c
+++ b/tcg/sparc/tcg-target.inc.c
@@ -291,14 +291,14 @@ static inline int check_fit_i32(int32_t val, unsigned int bits)
 # define check_fit_ptr  check_fit_i32
 #endif
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     uint32_t insn = *code_ptr;
     intptr_t pcrel;
 
     value += addend;
-    pcrel = tcg_ptr_byte_diff((tcg_insn_unit *)value, code_ptr);
+    pcrel = tcg_ptr_byte_diff((const tcg_insn_unit *)value, code_ptr);
 
     switch (type) {
     case R_SPARC_WDISP16:
@@ -845,7 +845,7 @@ static void tcg_out_addsub2_i64(TCGContext *s, TCGReg rl, TCGReg rh,
     tcg_out_mov(s, TCG_TYPE_I64, rl, tmp);
 }
 
-static void tcg_out_call_nodelay(TCGContext *s, tcg_insn_unit *dest,
+static void tcg_out_call_nodelay(TCGContext *s, const tcg_insn_unit *dest,
                                  bool in_prologue)
 {
     ptrdiff_t disp = tcg_pcrel_diff(s, dest);
@@ -860,7 +860,7 @@ static void tcg_out_call_nodelay(TCGContext *s, tcg_insn_unit *dest,
     }
 }
 
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *dest)
 {
     tcg_out_call_nodelay(s, dest, false);
     tcg_out_nop(s);
@@ -873,8 +873,8 @@ static void tcg_out_mb(TCGContext *s, TCGArg a0)
 }
 
 #ifdef CONFIG_SOFTMMU
-static tcg_insn_unit *qemu_ld_trampoline[16];
-static tcg_insn_unit *qemu_st_trampoline[16];
+static const tcg_insn_unit *qemu_ld_trampoline[16];
+static const tcg_insn_unit *qemu_st_trampoline[16];
 
 static void emit_extend(TCGContext *s, TCGReg r, int op)
 {
@@ -1053,11 +1053,11 @@ static void tcg_target_qemu_prologue(TCGContext *s)
 #endif
 }
 
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count)
 {
     int i;
     for (i = 0; i < count; ++i) {
-        p[i] = NOP;
+        (TCG_CODE_PTR_RW(s, p))[i] = NOP;
     }
 }
 
@@ -1168,7 +1168,7 @@ static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,
 #ifdef CONFIG_SOFTMMU
     unsigned memi = get_mmuidx(oi);
     TCGReg addrz, param;
-    tcg_insn_unit *func;
+    const tcg_insn_unit *func;
     tcg_insn_unit *label_ptr;
 
     addrz = tcg_out_tlb_load(s, addr, memi, memop,
@@ -1231,7 +1231,8 @@ static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,
         }
     }
 
-    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));
+    *TCG_CODE_PTR_RW(s, label_ptr) |=
+        INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));
 #else
     if (SPARC64 && TARGET_LONG_BITS == 32) {
         tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);
@@ -1827,7 +1828,7 @@ void tcg_register_jit(void *buf, size_t buf_size)
 }
 
 void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
-                              uintptr_t addr)
+                              uintptr_t addr, uintptr_t wr_addr)
 {
     intptr_t tb_disp = addr - tc_ptr;
     intptr_t br_disp = addr - jmp_addr;
@@ -1840,6 +1841,9 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
 
     if (!USE_REG_TB) {
         atomic_set((uint32_t *)jmp_addr, deposit32(CALL, 0, 30, br_disp >> 2));
+#if defined(CONFIG_IOS_JIT)
+        flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
         flush_icache_range(jmp_addr, jmp_addr + 4);
         return;
     }
@@ -1864,5 +1868,8 @@ void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_addr,
     }
 
     atomic_set((uint64_t *)jmp_addr, deposit64(i2, 32, 32, i1));
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 8);
+#endif
     flush_icache_range(jmp_addr, jmp_addr + 8);
 }
diff --git a/tcg/tcg-ldst.inc.c b/tcg/tcg-ldst.inc.c
index 05f9b3ccd6..eaba08700e 100644
--- a/tcg/tcg-ldst.inc.c
+++ b/tcg/tcg-ldst.inc.c
@@ -28,7 +28,7 @@ typedef struct TCGLabelQemuLdst {
     TCGReg addrhi_reg;      /* reg index for high word of guest virtual addr */
     TCGReg datalo_reg;      /* reg index for low word to be loaded or stored */
     TCGReg datahi_reg;      /* reg index for high word to be loaded or stored */
-    tcg_insn_unit *raddr;   /* gen code addr of the next IR of qemu_ld/st IR */
+    const tcg_insn_unit *raddr; /* gen code addr of the next IR of qemu_ld/st */
     tcg_insn_unit *label_ptr[2]; /* label pointers to be updated */
     QSIMPLEQ_ENTRY(TCGLabelQemuLdst) next;
 } TCGLabelQemuLdst;
diff --git a/tcg/tcg-pool.inc.c b/tcg/tcg-pool.inc.c
index 4eaa84b631..2c23162d74 100644
--- a/tcg/tcg-pool.inc.c
+++ b/tcg/tcg-pool.inc.c
@@ -119,7 +119,7 @@ static inline void new_pool_l8(TCGContext *s, int rtype, tcg_insn_unit *label,
 }
 
 /* To be provided by cpu/tcg-target.inc.c.  */
-static void tcg_out_nop_fill(tcg_insn_unit *p, int count);
+static void tcg_out_nop_fill(TCGContext *s, tcg_insn_unit *p, int count);
 
 static int tcg_out_pool_finalize(TCGContext *s)
 {
@@ -135,7 +135,7 @@ static int tcg_out_pool_finalize(TCGContext *s)
        again when allocating the next TranslationBlock structure.  */
     a = (void *)ROUND_UP((uintptr_t)s->code_ptr,
                          sizeof(tcg_target_ulong) * p->nlong);
-    tcg_out_nop_fill(s->code_ptr, (tcg_insn_unit *)a - s->code_ptr);
+    tcg_out_nop_fill(s, s->code_ptr, (tcg_insn_unit *)a - s->code_ptr);
     s->data_gen_ptr = a;
 
     for (; p != NULL; p = p->next) {
@@ -144,11 +144,12 @@ static int tcg_out_pool_finalize(TCGContext *s)
             if (unlikely(a > s->code_gen_highwater)) {
                 return -1;
             }
-            memcpy(a, p->data, size);
+            memcpy(TCG_CODE_PTR_RW(s, a), p->data, size);
             a += size;
             l = p;
         }
-        if (!patch_reloc(p->label, p->rtype, (intptr_t)a - size, p->addend)) {
+        if (!patch_reloc(s, p->label, p->rtype,
+                         (intptr_t)a - size, p->addend)) {
             return -2;
         }
     }
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 5475d49ed1..5a4073266a 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -70,7 +70,7 @@
 static void tcg_target_init(TCGContext *s);
 static const TCGTargetOpDef *tcg_target_op_def(TCGOpcode);
 static void tcg_target_qemu_prologue(TCGContext *s);
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend);
 
 /* The CIE and FDE header definitions will be common to all hosts.  */
@@ -148,7 +148,7 @@ static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
                        intptr_t arg2);
 static bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
                         TCGReg base, intptr_t ofs);
-static void tcg_out_call(TCGContext *s, tcg_insn_unit *target);
+static void tcg_out_call(TCGContext *s, const tcg_insn_unit *target);
 static int tcg_target_const_match(tcg_target_long val, TCGType type,
                                   const TCGArgConstraint *arg_ct);
 #ifdef TCG_TARGET_NEED_LDST_LABELS
@@ -203,13 +203,15 @@ static TCGRegSet tcg_target_call_clobber_regs;
 #if TCG_TARGET_INSN_UNIT_SIZE == 1
 static __attribute__((unused)) inline void tcg_out8(TCGContext *s, uint8_t v)
 {
-    *s->code_ptr++ = v;
+    *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+    s->code_ptr++;
 }
 
-static __attribute__((unused)) inline void tcg_patch8(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch8(TCGContext *s,
+                                                      tcg_insn_unit *p,
                                                       uint8_t v)
 {
-    *p = v;
+    *TCG_CODE_PTR_RW(s, p) = v;
 }
 #endif
 
@@ -217,21 +219,23 @@ static __attribute__((unused)) inline void tcg_patch8(tcg_insn_unit *p,
 static __attribute__((unused)) inline void tcg_out16(TCGContext *s, uint16_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 2) {
-        *s->code_ptr++ = v;
+        *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+        s->code_ptr++;
     } else {
         tcg_insn_unit *p = s->code_ptr;
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
         s->code_ptr = p + (2 / TCG_TARGET_INSN_UNIT_SIZE);
     }
 }
 
-static __attribute__((unused)) inline void tcg_patch16(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch16(TCGContext *s,
+                                                       tcg_insn_unit *p,
                                                        uint16_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 2) {
-        *p = v;
+        *TCG_CODE_PTR_RW(s, p) = v;
     } else {
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
     }
 }
 #endif
@@ -240,21 +244,23 @@ static __attribute__((unused)) inline void tcg_patch16(tcg_insn_unit *p,
 static __attribute__((unused)) inline void tcg_out32(TCGContext *s, uint32_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 4) {
-        *s->code_ptr++ = v;
+        *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+        s->code_ptr++;
     } else {
         tcg_insn_unit *p = s->code_ptr;
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
         s->code_ptr = p + (4 / TCG_TARGET_INSN_UNIT_SIZE);
     }
 }
 
-static __attribute__((unused)) inline void tcg_patch32(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch32(TCGContext *s,
+                                                       tcg_insn_unit *p,
                                                        uint32_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 4) {
         *p = v;
     } else {
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
     }
 }
 #endif
@@ -263,21 +269,23 @@ static __attribute__((unused)) inline void tcg_patch32(tcg_insn_unit *p,
 static __attribute__((unused)) inline void tcg_out64(TCGContext *s, uint64_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 8) {
-        *s->code_ptr++ = v;
+        *TCG_CODE_PTR_RW(s, s->code_ptr) = v;
+        s->code_ptr++;
     } else {
         tcg_insn_unit *p = s->code_ptr;
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
         s->code_ptr = p + (8 / TCG_TARGET_INSN_UNIT_SIZE);
     }
 }
 
-static __attribute__((unused)) inline void tcg_patch64(tcg_insn_unit *p,
+static __attribute__((unused)) inline void tcg_patch64(TCGContext *s,
+                                                       tcg_insn_unit *p,
                                                        uint64_t v)
 {
     if (TCG_TARGET_INSN_UNIT_SIZE == 8) {
         *p = v;
     } else {
-        memcpy(p, &v, sizeof(v));
+        memcpy(TCG_CODE_PTR_RW(s, p), &v, sizeof(v));
     }
 }
 #endif
@@ -295,7 +303,7 @@ static void tcg_out_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
     QSIMPLEQ_INSERT_TAIL(&l->relocs, r, next);
 }
 
-static void tcg_out_label(TCGContext *s, TCGLabel *l, tcg_insn_unit *ptr)
+static void tcg_out_label(TCGContext *s, TCGLabel *l, const tcg_insn_unit *ptr)
 {
     tcg_debug_assert(!l->has_value);
     l->has_value = 1;
@@ -325,7 +333,7 @@ static bool tcg_resolve_relocs(TCGContext *s)
         uintptr_t value = l->u.value;
 
         QSIMPLEQ_FOREACH(r, &l->relocs, next) {
-            if (!patch_reloc(r->ptr, r->type, value, r->addend)) {
+            if (!patch_reloc(s, r->ptr, r->type, value, r->addend)) {
                 return false;
             }
         }
@@ -1034,7 +1042,7 @@ TranslationBlock *tcg_tb_alloc(TCGContext *s)
     }
     atomic_set(&s->code_gen_ptr, next);
     s->data_gen_ptr = NULL;
-    return tb;
+    return (TranslationBlock *)TCG_CODE_PTR_RW(s, tb);
 }
 
 void tcg_prologue_init(TCGContext *s)
@@ -1071,6 +1079,10 @@ void tcg_prologue_init(TCGContext *s)
 #endif
 
     buf1 = s->code_ptr;
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range((uintptr_t)TCG_CODE_PTR_RW(s, buf0),
+                       (uintptr_t)TCG_CODE_PTR_RW(s, buf1));
+#endif
     flush_icache_range((uintptr_t)buf0, (uintptr_t)buf1);
 
     /* Deduct the prologue from the buffer.  */
@@ -4221,6 +4233,12 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb)
         return -2;
     }
 
+#if defined(CONFIG_IOS_JIT)
+    /* flush data cache on mirror */
+    flush_dcache_range((uintptr_t)TCG_CODE_PTR_RW(s, s->code_buf),
+                       (uintptr_t)TCG_CODE_PTR_RW(s, s->code_ptr));
+#endif
+
     /* flush instruction cache */
     flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);
 
diff --git a/tcg/tcg.h b/tcg/tcg.h
index 92ca10dffc..a9e5b9ed22 100644
--- a/tcg/tcg.h
+++ b/tcg/tcg.h
@@ -258,7 +258,7 @@ struct TCGLabel {
     unsigned refs : 16;
     union {
         uintptr_t value;
-        tcg_insn_unit *value_ptr;
+        const tcg_insn_unit *value_ptr;
     } u;
     QSIMPLEQ_HEAD(, TCGRelocation) relocs;
     QSIMPLEQ_ENTRY(TCGLabel) next;
@@ -590,7 +590,7 @@ struct TCGContext {
     int nb_ops;
 
     /* goto_tb support */
-    tcg_insn_unit *code_buf;
+    const tcg_insn_unit *code_buf;
     uint16_t *tb_jmp_reset_offset; /* tb->jmp_reset_offset */
     uintptr_t *tb_jmp_insn_offset; /* tb->jmp_target_arg if direct_jump */
     uintptr_t *tb_jmp_target_addr; /* tb->jmp_target_arg if !direct_jump */
@@ -624,6 +624,9 @@ struct TCGContext {
     size_t code_gen_buffer_size;
     void *code_gen_ptr;
     void *data_gen_ptr;
+#if defined(CONFIG_IOS_JIT)
+    ptrdiff_t code_rw_mirror_diff;
+#endif
 
     /* Threshold to flush the translated code buffer.  */
     void *code_gen_highwater;
@@ -674,6 +677,13 @@ struct TCGContext {
     target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];
 };
 
+#if defined(CONFIG_IOS_JIT)
+# define TCG_CODE_PTR_RW(s, code_ptr) \
+    (tcg_insn_unit *)((uintptr_t)(code_ptr) + (s)->code_rw_mirror_diff)
+#else
+# define TCG_CODE_PTR_RW(s, code_ptr) (code_ptr)
+#endif
+
 extern TCGContext tcg_init_ctx;
 extern __thread TCGContext *tcg_ctx;
 extern TCGv_env cpu_env;
@@ -1086,7 +1096,7 @@ static inline TCGLabel *arg_label(TCGArg i)
  * correct result.
  */
 
-static inline ptrdiff_t tcg_ptr_byte_diff(void *a, void *b)
+static inline ptrdiff_t tcg_ptr_byte_diff(const void *a, const void *b)
 {
     return a - b;
 }
@@ -1100,7 +1110,7 @@ static inline ptrdiff_t tcg_ptr_byte_diff(void *a, void *b)
  * to the destination address.
  */
 
-static inline ptrdiff_t tcg_pcrel_diff(TCGContext *s, void *target)
+static inline ptrdiff_t tcg_pcrel_diff(TCGContext *s, const void *target)
 {
     return tcg_ptr_byte_diff(target, s->code_ptr);
 }
diff --git a/tcg/tci/tcg-target.h b/tcg/tci/tcg-target.h
index 8b90ab71cb..e6bf09d12c 100644
--- a/tcg/tci/tcg-target.h
+++ b/tcg/tci/tcg-target.h
@@ -195,6 +195,13 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
 }
 
+#if defined(CONFIG_IOS_JIT)
+static inline void flush_dcache_range(uintptr_t start, uintptr_t stop)
+{
+#error "Unimplemented dcache flush function"
+}
+#endif
+
 /* We could notice __i386__ or __s390x__ and reduce the barriers depending
    on the host.  But if you want performance, you use the normal backend.
    We prefer consistency across hosts on this.  */
@@ -203,11 +210,15 @@ static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
 static inline void tb_target_set_jmp_target(uintptr_t tc_ptr,
-                                            uintptr_t jmp_addr, uintptr_t addr)
+                                            uintptr_t jmp_addr, uintptr_t addr,
+                                            uintptr_t wr_addr)
 {
     /* patch the branch destination */
     atomic_set((int32_t *)jmp_addr, addr - (jmp_addr + 4));
     /* no need to flush icache explicitly */
+#if defined(CONFIG_IOS_JIT)
+    flush_dcache_range(wr_addr, wr_addr + 4);
+#endif
 }
 
 #endif /* TCG_TARGET_H */
diff --git a/tcg/tci/tcg-target.inc.c b/tcg/tci/tcg-target.inc.c
index 992d50cb1e..baacafa983 100644
--- a/tcg/tci/tcg-target.inc.c
+++ b/tcg/tci/tcg-target.inc.c
@@ -369,7 +369,7 @@ static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
 };
 #endif
 
-static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+static bool patch_reloc(TCGContext *s, tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
     /* tcg_out_reloc always uses the same type, addend. */
@@ -377,9 +377,9 @@ static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
     tcg_debug_assert(addend == 0);
     tcg_debug_assert(value != 0);
     if (TCG_TARGET_REG_BITS == 32) {
-        tcg_patch32(code_ptr, value);
+        tcg_patch32(s, code_ptr, value);
     } else {
-        tcg_patch64(code_ptr, value);
+        tcg_patch64(s, code_ptr, value);
     }
     return true;
 }
@@ -546,7 +546,7 @@ static void tcg_out_movi(TCGContext *s, TCGType type,
     old_code_ptr[1] = s->code_ptr - old_code_ptr;
 }
 
-static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *arg)
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
 {
     uint8_t *old_code_ptr = s->code_ptr;
     tcg_out_op_t(s, INDEX_op_call);
-- 
2.21.1 (Apple Git-122.3)

diff -Naur a/libucontext/LICENSE b/libucontext/LICENSE
--- a/libucontext/LICENSE	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/LICENSE	2020-01-31 16:28:55.000000000 -0800
@@ -0,0 +1,9 @@
+Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+This software is provided 'as is' and without any warranty, express or
+implied.  In no event shall the authors be liable for any damages arising
+from the use of this software.
diff -Naur a/libucontext/Makefile b/libucontext/Makefile
--- a/libucontext/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/Makefile	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,51 @@
+ARCH := $(shell uname -m)
+
+ROOT_DIR := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+BUILD_DIR ?= .
+
+LIBUCONTEXT = $(BUILD_DIR)/libucontext.a
+
+all: $(LIBUCONTEXT)
+
+CSRCS := $(wildcard arch/${ARCH}/*.c)
+SSRCS := $(wildcard arch/${ARCH}/*.S)
+OBJS := $(CSRCS:%.c=$(BUILD_DIR)/%.o) $(SSRCS:%.S=$(BUILD_DIR)/%.o)
+DEPS := $(OBJS:%.o=%.d)
+
+INC_DIRS := include $(BUILD_DIR)/arch/${ARCH}
+INC_FLAGS := $(addprefix -I,$(INC_DIRS))
+
+override CFLAGS +=					\
+	-DG_LOG_DOMAIN='"ucontext"'			\
+	$(INC_FLAGS)					\
+	-MMD -MP
+
+$(LIBUCONTEXT): $(OBJS)
+
+.PHONY: clean
+
+clean:
+	rm -r $(OBJS) $(DEPS) $(LIBUCONTEXT)
+
+$(BUILD_DIR)/arch/${ARCH}/%.o: $(ROOT_DIR)/arch/${ARCH}/%.c
+	@$(MKDIR_P) $(dir $@)
+	$(call quiet-command,$(CC) $(CFLAGS) -c -o $@ $<,"CC","$@")
+
+$(BUILD_DIR)/arch/${ARCH}/%.o: $(ROOT_DIR)/arch/${ARCH}/%.S
+	@$(MKDIR_P) $(dir $@)
+	$(call quiet-command,$(CC) $(CFLAGS) -c -o $@ $<,"CC","$@")
+
+%.a:
+	$(call quiet-command,rm -f $@ && $(AR) rcs $@ $^,"AR","$@")
+
+MKDIR_P ?= mkdir -p
+quiet-command-run = $(if $(V),,$(if $2,printf "  %-7s %s\n" $2 $3 && ))$1
+quiet-@ = $(if $(V),,@)
+quiet-command = $(quiet-@)$(call quiet-command-run,$1,$2,$3)
+
+print-%:
+	@echo '$*=$($*)'
+
+.SUFFIXES:
+
+-include $(DEPS)
diff -Naur a/libucontext/README.md b/libucontext/README.md
--- a/libucontext/README.md	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/README.md	2020-01-31 16:28:55.000000000 -0800
@@ -0,0 +1,43 @@
+# `libucontext`
+
+`libucontext` is a library which provides the `ucontext.h` C API.  Unlike other implementations,
+it faithfully follows the kernel process ABI when doing context swaps.
+
+Notably, when combined with `gcompat`, it provides a fully compatible implementation of the ucontext
+functions that are ABI compatible with glibc.
+
+
+## supported architectures
+
+Adding support for new architectures is easy, but you need to know assembly language to do it.
+
+Right now these archs are supported and should work on bare metal:
+
+ * x86
+ * x86_64
+ * armv6+ (`arm`)
+ * aarch64
+ * s390x
+
+These archs require kernel assistance and use a syscall (the only assembly is the trampoline):
+
+ * ppc
+ * ppc64 (ELFv2 ABI spec only, ELFv1 not supported)
+
+
+## building
+
+`libucontext` uses a simple makefile build system.  You should define `ARCH=` at build time, otherwise
+the build system will attempt to guess using `uname -m`.
+
+```
+$ make ARCH=x86_64
+$ make ARCH=x86_64 check
+$ make ARCH=x86_64 DESTDIR=out install
+```
+
+
+## support
+
+`libucontext` is offered as part of the `gcompat` project.  Accordingly, please address all questions
+and bug reports to gcompat@lists.adelielinux.org.
diff -Naur a/libucontext/arch/aarch64/defs.h b/libucontext/arch/aarch64/defs.h
--- a/libucontext/arch/aarch64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,25 @@
+#ifndef __ARCH_AARCH64_DEFS_H
+#define __ARCH_AARCH64_DEFS_H
+
+#define REGSZ   8
+#ifdef CUSTOM_IMPL
+#define R0_OFFSET 56
+#define SP_OFFSET 304
+#define PC_OFFSET 312
+#define PSTATE_OFFSET 320
+#else
+#define R0_OFFSET 184
+#define SP_OFFSET 432
+#define PC_OFFSET 440
+#define PSTATE_OFFSET 448
+#endif
+
+#ifndef FPSIMD_MAGIC
+# define FPSIMD_MAGIC	0x46508001
+#endif
+
+#ifndef ESR_MAGIC
+# define ESR_MAGIC	0x45535201
+#endif
+
+#endif
diff -Naur a/libucontext/arch/aarch64/getcontext.S b/libucontext/arch/aarch64/getcontext.S
--- a/libucontext/arch/aarch64/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_getcontext;
+_libucontext_getcontext:
+	str	xzr, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* save GPRs */
+	stp	x0, x1,   [x0, #R0_OFFSET + (0 * REGSZ)]
+	stp	x2, x3,   [x0, #R0_OFFSET + (2 * REGSZ)]
+	stp	x4, x5,   [x0, #R0_OFFSET + (4 * REGSZ)]
+	stp	x6, x7,   [x0, #R0_OFFSET + (6 * REGSZ)]
+	stp	x8, x9,   [x0, #R0_OFFSET + (8 * REGSZ)]
+	stp	x10, x11, [x0, #R0_OFFSET + (10 * REGSZ)]
+	stp	x12, x13, [x0, #R0_OFFSET + (12 * REGSZ)]
+	stp	x14, x15, [x0, #R0_OFFSET + (14 * REGSZ)]
+	stp	x16, x17, [x0, #R0_OFFSET + (16 * REGSZ)]
+	stp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	stp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	stp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	stp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	stp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	stp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	str	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current program counter in link register */
+	str	x30, [x0, #PC_OFFSET]
+
+	/* save current stack pointer */
+	mov	x2, sp
+	str	x2, [x0, #SP_OFFSET]
+
+	/* save pstate */
+	str	xzr, [x0, #PSTATE_OFFSET]
+
+	/* TODO: SIMD / FPRs */
+
+	mov	x0, #0
+	ret
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak getcontext;
+getcontext = _libucontext_getcontext;
+#endif
diff -Naur a/libucontext/arch/aarch64/makecontext.c b/libucontext/arch/aarch64/makecontext.c
--- a/libucontext/arch/aarch64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdarg.h>
+#ifdef CUSTOM_IMPL
+#include <libucontext.h>
+#define UCONTEXT_T libucontext_ucontext_t
+#else
+#define UCONTEXT_T ucontext_t
+#define _GNU_SOURCE
+#include <signal.h>
+#include <string.h>
+#include <stdio.h>
+#endif
+#include "defs.h"
+
+
+extern void _start_context(void);
+
+
+void
+libucontext_makecontext(UCONTEXT_T *ucp, void (*func)(void), int argc, ...)
+{
+	unsigned long *sp;
+	unsigned long *regp;
+	va_list va;
+	int i;
+
+	sp = (unsigned long *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= argc < 8 ? 0 : argc - 8;
+	sp = (unsigned long *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.sp = (uintptr_t) sp;
+	ucp->uc_mcontext.pc = (uintptr_t) func;
+	ucp->uc_mcontext.regs[19] = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.regs[30] = (uintptr_t) &_start_context;
+
+	va_start(va, argc);
+
+	regp = &(ucp->uc_mcontext.regs[0]);
+
+	for (i = 0; (i < argc && i < 8); i++)
+		*regp++ = va_arg (va, unsigned long);
+
+	for (; i < argc; i++)
+		*sp++ = va_arg (va, unsigned long);
+
+	va_end(va);
+}
+
+
+#ifndef CUSTOM_IMPL
+extern __typeof(libucontext_makecontext) makecontext __attribute__((weak, __alias__("libucontext_makecontext")));
+#endif
diff -Naur a/libucontext/arch/aarch64/setcontext.S b/libucontext/arch/aarch64/setcontext.S
--- a/libucontext/arch/aarch64/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_setcontext;
+_libucontext_setcontext:
+	/* restore GPRs */
+	ldp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	ldp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	ldp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	ldp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	ldp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	ldp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	ldr	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current stack pointer */
+	ldr	x2, [x0, #SP_OFFSET]
+	mov	sp, x2
+
+	/* TODO: SIMD / FPRs */
+
+	/* save current program counter in link register */
+	ldr	x16, [x0, #PC_OFFSET]
+
+	/* restore args */
+	ldp	x2, x3, [x0, #R0_OFFSET + (2 * REGSZ)]
+	ldp	x4, x5, [x0, #R0_OFFSET + (4 * REGSZ)]
+	ldp	x6, x7, [x0, #R0_OFFSET + (6 * REGSZ)]
+	ldp	x0, x1, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* jump to new PC */
+	br	x16
+.align 2
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	mov	x0, x19
+	cbnz	x0, _libucontext_setcontext
+
+	/* something went wrong, exit */
+	b	_exit
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak setcontext;
+setcontext = _libucontext_setcontext;
+#endif
diff -Naur a/libucontext/arch/aarch64/swapcontext.S b/libucontext/arch/aarch64/swapcontext.S
--- a/libucontext/arch/aarch64/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_swapcontext;
+_libucontext_swapcontext:
+	str	xzr, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* save GPRs */
+	stp	x2, x3,   [x0, #R0_OFFSET + (2 * REGSZ)]
+	stp	x4, x5,   [x0, #R0_OFFSET + (4 * REGSZ)]
+	stp	x6, x7,   [x0, #R0_OFFSET + (6 * REGSZ)]
+	stp	x8, x9,   [x0, #R0_OFFSET + (8 * REGSZ)]
+	stp	x10, x11, [x0, #R0_OFFSET + (10 * REGSZ)]
+	stp	x12, x13, [x0, #R0_OFFSET + (12 * REGSZ)]
+	stp	x14, x15, [x0, #R0_OFFSET + (14 * REGSZ)]
+	stp	x16, x17, [x0, #R0_OFFSET + (16 * REGSZ)]
+	stp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	stp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	stp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	stp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	stp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	stp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	str	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current program counter in link register */
+	str	x30, [x0, #PC_OFFSET]
+
+	/* save current stack pointer */
+	mov	x2, sp
+	str	x2, [x0, #SP_OFFSET]
+
+	/* save pstate */
+	str	xzr, [x0, #PSTATE_OFFSET]
+
+	/* context to swap to is in x1 so... we move to x0 and call setcontext */
+	/* store our link register in x28 */
+	mov	x28, x30
+
+	/* move x1 to x0 and call setcontext */
+	mov	x0, x1
+	bl	_libucontext_setcontext
+
+	/* hmm, we came back here try to return */
+	mov	x30, x28
+	ret
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak swapcontext;
+swapcontext = _libucontext_swapcontext;
+#endif
diff -Naur a/libucontext/arch/arm/getcontext.S b/libucontext/arch/arm/getcontext.S
--- a/libucontext/arch/arm/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __getcontext;
+__getcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r1, r0, #48
+	stmia	r1, {r4-r12}
+	str	r13, [r0,#84]
+	str	r14, [r0,#92]
+
+	/* return 0 */
+	mov	r0, #0
+	mov	pc, lr
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/arm/makecontext.c b/libucontext/arch/arm/makecontext.c
--- a/libucontext/arch/arm/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdio.h>
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	unsigned long *sp;
+	unsigned long *regp;
+	va_list va;
+	int i;
+
+	sp = (unsigned long *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp = (unsigned long *) (((uintptr_t) sp & -16L) - 8);
+
+	if (argc > 4)
+		sp -= (argc - 4);
+
+	ucp->uc_mcontext.arm_sp = (uintptr_t) sp;
+	ucp->uc_mcontext.arm_pc = (uintptr_t) func;
+	ucp->uc_mcontext.arm_r4 = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.arm_lr = (uintptr_t) &__start_context;
+
+	va_start(va, argc);
+
+	regp = &(ucp->uc_mcontext.arm_r0);
+
+	for (i = 0; (i < argc && i < 4); i++)
+		*regp++ = va_arg (va, unsigned long);
+
+	for (; i < argc; i++)
+		*sp++ = va_arg (va, unsigned long);
+
+	va_end(va);
+
+/*
+	printf("R4 offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_r4));
+	printf("SP offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_sp));
+	printf("LR offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_lr));
+	printf("PC offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_pc));
+ */
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/arm/setcontext.S b/libucontext/arch/arm/setcontext.S
--- a/libucontext/arch/arm/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __setcontext;
+__setcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r14, r0, #32
+	ldmia	r14, {r0-r12}
+	ldr	r13, [r14, #52]
+	add	r14, r14, #56
+
+	/* load link register and jump to new context */
+	ldmia	r14, {r14, pc}
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/arm/startcontext.S b/libucontext/arch/arm/startcontext.S
--- a/libucontext/arch/arm/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+.fnstart
+.cantunwind
+	nop
+__start_context:
+	/* get the proper context into position and test for NULL */
+	movs	r0, r4
+	bne	__setcontext@plt
+
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	b	exit@plt
diff -Naur a/libucontext/arch/arm/swapcontext.S b/libucontext/arch/arm/swapcontext.S
--- a/libucontext/arch/arm/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __swapcontext;
+__swapcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r2, r0, #32
+	stmia	r2, {r0-r12}
+	str	r13, [r0,#84]
+	str	r14, [r0,#92]
+
+	/* load new registers from the second ucontext structure */
+	add	r14, r1, #32
+	ldmia	r14, {r0-r12}
+	ldr	r13, [r14, #52]
+	add	r14, r14, #56
+	ldmia	r14, {r14, pc}
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/ppc/defs.h b/libucontext/arch/ppc/defs.h
--- a/libucontext/arch/ppc/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,62 @@
+#ifndef __ARCH_PPC_DEFS_H
+#define __ARCH_PPC_DEFS_H
+
+#define REG_R0		(0)
+#define REG_R1		(1)
+#define REG_R2		(2)
+#define REG_R3		(3)
+#define REG_R4		(4)
+#define REG_R5		(5)
+#define REG_R6		(6)
+#define REG_R7		(7)
+#define REG_R8		(8)
+#define REG_R9		(9)
+#define REG_R10		(10)
+#define REG_R11		(11)
+#define REG_R12		(12)
+#define REG_R13		(13)
+#define REG_R14		(14)
+#define REG_R15		(15)
+#define REG_R16		(16)
+#define REG_R17		(17)
+#define REG_R18		(18)
+#define REG_R19		(19)
+#define REG_R20		(20)
+#define REG_R21		(21)
+#define REG_R22		(22)
+#define REG_R23		(23)
+#define REG_R24		(24)
+#define REG_R25		(25)
+#define REG_R26		(26)
+#define REG_R27		(27)
+#define REG_R28		(28)
+#define REG_R29		(29)
+#define REG_R30		(30)
+#define REG_R31		(31)
+#define REG_R32		(32)
+#define REG_R33		(33)
+#define REG_R34		(34)
+#define REG_R35		(35)
+#define REG_R36		(36)
+#define REG_R37		(37)
+#define REG_R38		(38)
+#define REG_R39		(39)
+#define REG_R40		(40)
+#define REG_R41		(41)
+#define REG_R42		(42)
+#define REG_R43		(43)
+#define REG_R44		(44)
+#define REG_R45		(45)
+#define REG_R46		(46)
+#define REG_R47		(47)
+
+/* sp register is actually %r1 */
+#define REG_SP		REG_R1
+
+/* nip register is actually %srr0 (r32) */
+#define REG_NIP		REG_R32
+
+/* lnk register is actually r32 */
+#define REG_LNK		REG_R36
+
+#endif
diff -Naur a/libucontext/arch/ppc/getcontext.c b/libucontext/arch/ppc/getcontext.c
--- a/libucontext/arch/ppc/getcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/getcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__getcontext(ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, ucp, NULL, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return 0;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__getcontext) getcontext __attribute__((weak, __alias__("__getcontext")));
diff -Naur a/libucontext/arch/ppc/makecontext.c b/libucontext/arch/ppc/makecontext.c
--- a/libucontext/arch/ppc/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link, stack_args;
+
+	stack_args = argc > 8 ? argc - 8 : 0;
+	uc_link = stack_args + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= (uc_link + 1);
+	sp = (greg_t *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_NIP]  = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_LNK]  = (uintptr_t) &__start_context;
+	ucp->uc_mcontext.gregs[REG_R31]  = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.gregs[REG_SP]   = (uintptr_t) sp;
+
+	sp[0] = (uintptr_t) &__start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+	argp = &sp[2];
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			ucp->uc_mcontext.gregs[i + 3] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/ppc/setcontext.c b/libucontext/arch/ppc/setcontext.c
--- a/libucontext/arch/ppc/setcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/setcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__setcontext(const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, NULL, (void *) ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__setcontext) setcontext __attribute__((weak, __alias__("__setcontext")));
diff -Naur a/libucontext/arch/ppc/startcontext.S b/libucontext/arch/ppc/startcontext.S
--- a/libucontext/arch/ppc/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	mr.	3,31
+
+	/* if we have no linked context, lets get out of here */
+	beq	no_linked_context
+
+	/* jump to setcontext */
+	bl	__setcontext@local
+
+no_linked_context:
+	b	exit@GOT
diff -Naur a/libucontext/arch/ppc/swapcontext.c b/libucontext/arch/ppc/swapcontext.c
--- a/libucontext/arch/ppc/swapcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/swapcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__swapcontext(ucontext_t *oucp, const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, oucp, ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__swapcontext) swapcontext __attribute__((weak, __alias__("__swapcontext")));
diff -Naur a/libucontext/arch/ppc64/defs.h b/libucontext/arch/ppc64/defs.h
--- a/libucontext/arch/ppc64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+#ifndef __ARCH_PPC_DEFS_H
+#define __ARCH_PPC_DEFS_H
+
+#define REG_R0		(0)
+#define REG_R1		(1)
+#define REG_R2		(2)
+#define REG_R3		(3)
+#define REG_R4		(4)
+#define REG_R5		(5)
+#define REG_R6		(6)
+#define REG_R7		(7)
+#define REG_R8		(8)
+#define REG_R9		(9)
+#define REG_R10		(10)
+#define REG_R11		(11)
+#define REG_R12		(12)
+#define REG_R13		(13)
+#define REG_R14		(14)
+#define REG_R15		(15)
+#define REG_R16		(16)
+#define REG_R17		(17)
+#define REG_R18		(18)
+#define REG_R19		(19)
+#define REG_R20		(20)
+#define REG_R21		(21)
+#define REG_R22		(22)
+#define REG_R23		(23)
+#define REG_R24		(24)
+#define REG_R25		(25)
+#define REG_R26		(26)
+#define REG_R27		(27)
+#define REG_R28		(28)
+#define REG_R29		(29)
+#define REG_R30		(30)
+#define REG_R31		(31)
+#define REG_R32		(32)
+#define REG_R33		(33)
+#define REG_R34		(34)
+#define REG_R35		(35)
+#define REG_R36		(36)
+#define REG_R37		(37)
+#define REG_R38		(38)
+#define REG_R39		(39)
+#define REG_R40		(40)
+#define REG_R41		(41)
+#define REG_R42		(42)
+#define REG_R43		(43)
+#define REG_R44		(44)
+#define REG_R45		(45)
+#define REG_R46		(46)
+#define REG_R47		(47)
+
+/* sp register is actually %r1 */
+#define REG_SP		REG_R1
+
+/* nip register is actually %srr0 (r32) */
+#define REG_NIP		REG_R32
+
+/* entry register is actually %r12 */
+#define REG_ENTRY	REG_R12
+
+/* lnk register is actually %r36 */
+#define REG_LNK		REG_R36
+
+#endif
diff -Naur a/libucontext/arch/ppc64/getcontext.c b/libucontext/arch/ppc64/getcontext.c
--- a/libucontext/arch/ppc64/getcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/getcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__getcontext(ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, ucp, NULL, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return 0;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__getcontext) getcontext __attribute__((weak, __alias__("__getcontext")));
diff -Naur a/libucontext/arch/ppc64/makecontext.c b/libucontext/arch/ppc64/makecontext.c
--- a/libucontext/arch/ppc64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link, stack_args;
+
+	stack_args = argc > 8 ? argc - 8 : 0;
+	uc_link = stack_args + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= (uc_link + 1);
+	sp = (greg_t *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.gp_regs[REG_NIP]   = (uintptr_t) func;
+	ucp->uc_mcontext.gp_regs[REG_LNK]   = (uintptr_t) &__start_context;
+	ucp->uc_mcontext.gp_regs[REG_SP]    = (uintptr_t) sp;
+	ucp->uc_mcontext.gp_regs[REG_ENTRY] = (uintptr_t) func;
+	ucp->uc_mcontext.gp_regs[REG_R31]   = (uintptr_t) ucp->uc_link;
+
+	sp[0] = (uintptr_t) &__start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+	argp = &sp[2];
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			ucp->uc_mcontext.gp_regs[i + 3] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/ppc64/setcontext.c b/libucontext/arch/ppc64/setcontext.c
--- a/libucontext/arch/ppc64/setcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/setcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__setcontext(const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, NULL, (void *) ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__setcontext) setcontext __attribute__((weak, __alias__("__setcontext")));
diff -Naur a/libucontext/arch/ppc64/startcontext.S b/libucontext/arch/ppc64/startcontext.S
--- a/libucontext/arch/ppc64/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+.hidden __start_context;
+__start_context:
+	cmpdi	31,0			/* test if ucontext link pointer is null */
+	beq	no_linked_context	/* if it is, exit */
+
+	/* now, call SYS_swapcontext */
+	mr      4,31			/* ucp is in r31 */
+	li      3,0			/* don't care about restoring, set oucp to NULL */
+	li      5,1696			/* sizeof(ucontext_t) */
+	li      0,249			/* SYS_swapcontext */
+	sc
+
+	/* we should not wind back up here, if we do, exit with -1 */
+	li	3,-1
+
+no_linked_context:
+	b	exit@GOT
+	nop
diff -Naur a/libucontext/arch/ppc64/swapcontext.c b/libucontext/arch/ppc64/swapcontext.c
--- a/libucontext/arch/ppc64/swapcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/swapcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__swapcontext(ucontext_t *oucp, const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, oucp, ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__swapcontext) swapcontext __attribute__((weak, __alias__("__swapcontext")));
diff -Naur a/libucontext/arch/s390x/defs.h b/libucontext/arch/s390x/defs.h
--- a/libucontext/arch/s390x/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,8 @@
+#ifndef __ARCH_S390X_DEFS_H
+#define __ARCH_S390X_DEFS_H
+
+#define OFFSET_GREGS	(56)
+#define OFFSET_AREGS	(184)
+#define OFFSET_FPREGS	(248)
+
+#endif
diff -Naur a/libucontext/arch/s390x/getcontext.S b/libucontext/arch/s390x/getcontext.S
--- a/libucontext/arch/s390x/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __getcontext;
+__getcontext:
+	lgr	%r1, %r2			/* use %r1 as our working register */
+	la	%r2, 0				/* we will return 0 */
+
+	stam	%a0, %a15, OFFSET_AREGS(%r1)	/* store access registers */
+	stmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	br	%r14				/* return to where we came from */
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/s390x/makecontext.c b/libucontext/arch/s390x/makecontext.c
--- a/libucontext/arch/s390x/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+extern int __setcontext(const ucontext_t *ucp);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int stack_args;
+
+	stack_args = argc > 5 ? argc - 5 : 0;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= stack_args;		// maybe +1
+	sp = (greg_t *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.gregs[7]  = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[8]  = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.gregs[9]  = (uintptr_t) &__setcontext;
+	ucp->uc_mcontext.gregs[14] = (uintptr_t) &__start_context;
+
+	argp = sp;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+			ucp->uc_mcontext.gregs[i + 2] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+
+	/* make room for backchain / register save area */
+	sp -= 20;
+	*sp = 0;
+
+	/* set up %r15 as sp */
+	ucp->uc_mcontext.gregs[15] = (uintptr_t) sp;
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/s390x/setcontext.S b/libucontext/arch/s390x/setcontext.S
--- a/libucontext/arch/s390x/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __setcontext;
+__setcontext:
+	lgr	%r1, %r2			/* use %r1 as our working register */
+
+	lam	%a2, %a15, OFFSET_AREGS+8(%r1)	/* load access registers, but skip %a0 and %a1 which are for TLS */
+	lmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	br	%r14				/* return to new link register address */
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/s390x/startcontext.S b/libucontext/arch/s390x/startcontext.S
--- a/libucontext/arch/s390x/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __start_context;
+__start_context:
+	basr	%r14, %r7			/* run function pointer (%r7) and return here */
+	ltgr	%r8, %r8			/* check to see if uc_link (%r8) is null */
+
+	jz	no_linked_context		/* if we have no linked context, prepare to exit */
+
+	lgr	%r2, %r8			/* copy the uc_link structure address to %r2 */
+	br	%r9				/* call setcontext */
+
+no_linked_context:
+	la	%r2, 0				/* return 0 */
+	brasl	%r14, exit@plt			/* call exit */
+
+	j	.+2				/* crash if exit returns */
diff -Naur a/libucontext/arch/s390x/swapcontext.S b/libucontext/arch/s390x/swapcontext.S
--- a/libucontext/arch/s390x/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __swapcontext;
+__swapcontext:
+	lgr	%r1, %r2			/* use %r1 to save current context to */
+	lgr	%r0, %r3			/* use %r0 for source context */
+
+	stam	%a0, %a15, OFFSET_AREGS(%r1)	/* store access registers */
+	stmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	lgr	%r2, %r0			/* swap %r0 to %r2 (XXX: figure out why it hates loading from %r0) */
+	lam	%a2, %a15, OFFSET_AREGS+8(%r2)	/* load access registers, but skip %a0 and %a1 which are for TLS */
+	lmg	%r0, %r15, OFFSET_GREGS(%r2)	/* load general-purpose registers */
+
+	br	%r14				/* return to new link register address */
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/x86/defs.h b/libucontext/arch/x86/defs.h
--- a/libucontext/arch/x86/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,18 @@
+#ifndef __ARCH_X86_DEFS_H
+#define __ARCH_X86_DEFS_H
+
+#define OFFSET_REG_GS	20
+#define OFFSET_REG_FS	24
+#define OFFSET_REG_ES	28
+#define OFFSET_REG_DS	32
+#define OFFSET_REG_EDI	36
+#define OFFSET_REG_ESI	40
+#define OFFSET_REG_EBP	44
+#define OFFSET_REG_ESP	48
+#define OFFSET_REG_EBX	52
+#define OFFSET_REG_EDX	56
+#define OFFSET_REG_ECX	60
+#define OFFSET_REG_EAX	64
+#define OFFSET_REG_EIP	76
+
+#endif
diff -Naur a/libucontext/arch/x86/getcontext.S b/libucontext/arch/x86/getcontext.S
--- a/libucontext/arch/x86/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __getcontext;
+__getcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* EAX is not a preserved register */
+	movl	$0, OFFSET_REG_EAX(%eax)
+
+	/* copy all of the current registers into the ucontext structure */
+	movl	%ecx, OFFSET_REG_ECX(%eax)
+	movl	%ebx, OFFSET_REG_EBX(%eax)
+	movl	%edx, OFFSET_REG_EDX(%eax)
+	movl	%edi, OFFSET_REG_EDI(%eax)
+	movl	%esi, OFFSET_REG_ESI(%eax)
+	movl	%ebp, OFFSET_REG_EBP(%eax)
+
+	/* the first argument on the stack is the jump target (%eip), so we store it in the EIP
+	   register in the ucontext structure. */
+	movl	(%esp), %ecx
+	movl	%ecx, OFFSET_REG_EIP(%eax)
+
+	/* take the stack pointer address (%esp) offsetting by 4 to skip over the jump target. */
+	leal	4(%esp), %ecx
+	movl	%ecx, OFFSET_REG_ESP(%eax)
+
+	/* finally, save the FS segment register */
+	xorl	%ecx, %ecx
+	movw	%fs, %cx
+	movl	%ecx, OFFSET_REG_FS(%eax)
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/x86/makecontext.c b/libucontext/arch/x86/makecontext.c
--- a/libucontext/arch/x86/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link;
+
+	uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= uc_link;
+	sp = (greg_t *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_EIP] = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_EBX] = (uintptr_t) argc;
+	ucp->uc_mcontext.gregs[REG_ESP] = (uintptr_t) sp;
+
+	argp = sp;
+	*argp++ = (uintptr_t) &__start_context;
+	*argp++ = (uintptr_t) ucp->uc_link;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		*argp++ = va_arg (va, greg_t);
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/x86/setcontext.S b/libucontext/arch/x86/setcontext.S
--- a/libucontext/arch/x86/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __setcontext;
+__setcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* set up the FS segment register */
+	movl	OFFSET_REG_FS(%eax), %ecx
+	movw	%cx, %fs
+
+	/* fetch the new EIP */
+	movl	OFFSET_REG_EIP(%eax), %ecx
+
+	/* set up the new stack pointer */
+	movl	OFFSET_REG_ESP(%eax), %esp
+
+	/* push the return address onto the stack */
+	pushl	%ecx
+
+	/* set all of the registers */
+	movl	OFFSET_REG_EBX(%eax), %ebx
+	movl	OFFSET_REG_ECX(%eax), %ecx
+	movl	OFFSET_REG_EDX(%eax), %edx
+	movl	OFFSET_REG_EBP(%eax), %ebp
+	movl	OFFSET_REG_EDI(%eax), %edi
+	movl	OFFSET_REG_ESI(%eax), %esi
+	movl	OFFSET_REG_EAX(%eax), %eax
+
+	ret
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/x86/startcontext.S b/libucontext/arch/x86/startcontext.S
--- a/libucontext/arch/x86/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	leal	(%esp,%ebx,4), %esp
+	cmpl	$0, (%esp)
+
+	/* restore global offset table, exit@plt and __setcontext@plt need this */
+	call	__i686.get_pc_thunk.bx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ebx
+
+	/* if we have no linked context, lets get out of here */
+	je	no_linked_context
+
+	/* call setcontext to switch to the linked context */
+	call	__setcontext@plt
+	movl	%eax, (%esp)
+
+no_linked_context:
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	call	exit@plt
+
+	/* something is really hosed, call hlt to force termination */
+	hlt
+
+
+__i686.get_pc_thunk.bx:
+	mov	(%esp), %ebx
+	ret
diff -Naur a/libucontext/arch/x86/swapcontext.S b/libucontext/arch/x86/swapcontext.S
--- a/libucontext/arch/x86/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __swapcontext;
+__swapcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* EAX is not a preserved register */
+	movl	$0, OFFSET_REG_EAX(%eax)
+
+	/* copy all of the current registers into the ucontext structure */
+	movl	%ecx, OFFSET_REG_ECX(%eax)
+	movl	%ebx, OFFSET_REG_EBX(%eax)
+	movl	%edx, OFFSET_REG_EDX(%eax)
+	movl	%edi, OFFSET_REG_EDI(%eax)
+	movl	%esi, OFFSET_REG_ESI(%eax)
+	movl	%ebp, OFFSET_REG_EBP(%eax)
+
+	/* the first argument on the stack is the jump target (%eip), so we store it in the EIP
+	   register in the ucontext structure. */
+	movl	(%esp), %ecx
+	movl	%ecx, OFFSET_REG_EIP(%eax)
+
+	/* take the stack pointer address (%esp) offsetting by 4 to skip over the jump target. */
+	leal	4(%esp), %ecx
+	movl	%ecx, OFFSET_REG_ESP(%eax)
+
+	/* finally, save the FS segment register */
+	xorl	%ecx, %ecx
+	movw	%fs, %cx
+	movl	%ecx, OFFSET_REG_FS(%eax)
+
+	/* load address of the ucontext structure */
+	movl	8(%esp), %eax
+
+	/* set up the FS segment register */
+	movl	OFFSET_REG_FS(%eax), %ecx
+	movw	%cx, %fs
+
+	/* fetch the new EIP */
+	movl	OFFSET_REG_EIP(%eax), %ecx
+
+	/* set up the new stack pointer */
+	movl	OFFSET_REG_ESP(%eax), %esp
+
+	/* push the return address onto the stack */
+	pushl	%ecx
+
+	/* set all of the registers */
+	movl	OFFSET_REG_EBX(%eax), %ebx
+	movl	OFFSET_REG_ECX(%eax), %ecx
+	movl	OFFSET_REG_EDX(%eax), %edx
+	movl	OFFSET_REG_EBP(%eax), %ebp
+	movl	OFFSET_REG_EDI(%eax), %edi
+	movl	OFFSET_REG_ESI(%eax), %esi
+	movl	OFFSET_REG_EAX(%eax), %eax
+
+	ret
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/x86_64/defs.h b/libucontext/arch/x86_64/defs.h
--- a/libucontext/arch/x86_64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/defs.h	2020-01-31 20:03:51.000000000 -0800
@@ -0,0 +1,55 @@
+#ifndef __ARCH_X86_64_DEFS_H
+#define __ARCH_X86_64_DEFS_H
+
+/* Number of each register in the `gregset_t' array.  */
+enum
+{
+  REG_R8 = 0,
+# define REG_R8		REG_R8
+  REG_R9,
+# define REG_R9		REG_R9
+  REG_R10,
+# define REG_R10	REG_R10
+  REG_R11,
+# define REG_R11	REG_R11
+  REG_R12,
+# define REG_R12	REG_R12
+  REG_R13,
+# define REG_R13	REG_R13
+  REG_R14,
+# define REG_R14	REG_R14
+  REG_R15,
+# define REG_R15	REG_R15
+  REG_RDI,
+# define REG_RDI	REG_RDI
+  REG_RSI,
+# define REG_RSI	REG_RSI
+  REG_RBP,
+# define REG_RBP	REG_RBP
+  REG_RBX,
+# define REG_RBX	REG_RBX
+  REG_RDX,
+# define REG_RDX	REG_RDX
+  REG_RAX,
+# define REG_RAX	REG_RAX
+  REG_RCX,
+# define REG_RCX	REG_RCX
+  REG_RSP,
+# define REG_RSP	REG_RSP
+  REG_RIP,
+# define REG_RIP	REG_RIP
+  REG_EFL,
+# define REG_EFL	REG_EFL
+  REG_CSGSFS,		/* Actually short cs, gs, fs, __pad0.  */
+# define REG_CSGSFS	REG_CSGSFS
+  REG_ERR,
+# define REG_ERR	REG_ERR
+  REG_TRAPNO,
+# define REG_TRAPNO	REG_TRAPNO
+  REG_OLDMASK,
+# define REG_OLDMASK	REG_OLDMASK
+  REG_CR2
+# define REG_CR2	REG_CR2
+};
+
+#endif
diff -Naur a/libucontext/arch/x86_64/getcontext.S b/libucontext/arch/x86_64/getcontext.S
--- a/libucontext/arch/x86_64/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_getcontext;
+_libucontext_getcontext:
+	/* copy all of the current registers into the ucontext structure */
+	movq	%r8, 40(%rdi)
+	movq	%r9, 48(%rdi)
+	movq	%r10, 56(%rdi)
+	movq	%r11, 64(%rdi)
+	movq	%r12, 72(%rdi)
+	movq	%r13, 80(%rdi)
+	movq	%r14, 88(%rdi)
+	movq	%r15, 96(%rdi)
+	movq	%rdi, 104(%rdi)
+	movq	%rsi, 112(%rdi)
+	movq	%rbp, 120(%rdi)
+	movq	%rbx, 128(%rdi)
+	movq	%rdx, 136(%rdi)
+	movq	$1, 144(%rdi)		/* $1 is %rax */
+	movq	%rcx, 152(%rdi)
+
+	/* the first argument on the stack is the jump target (%rip), so we store it in the RIP
+	   register in the ucontext structure. */
+	movq	(%rsp), %rcx
+	movq	%rcx, 168(%rdi)
+
+	/* finally take the stack pointer address (%rsp) offsetting by 8 to skip over the jump
+	   target. */
+	leaq	8(%rsp), %rcx
+	movq	%rcx, 160(%rdi)
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+#ifndef CUSTOM_IMPL
+.weak getcontext;
+getcontext = _libucontext_getcontext;
+#endif
diff -Naur a/libucontext/arch/x86_64/makecontext.c b/libucontext/arch/x86_64/makecontext.c
--- a/libucontext/arch/x86_64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/makecontext.c	2020-01-31 20:14:38.000000000 -0800
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <stddef.h>
+#include <stdarg.h>
+#ifdef CUSTOM_IMPL
+#include <libucontext.h>
+#include "defs.h"
+#define UCONTEXT_T libucontext_ucontext_t
+#define GREG_T libucontext_greg_t
+#else
+#define UCONTEXT_T ucontext_t
+#define GREG_T greg_t
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#endif
+#include "defs.h"
+
+
+extern void _start_context(void);
+
+
+void
+libucontext_makecontext(UCONTEXT_T *ucp, void (*func)(void), int argc, ...)
+{
+	GREG_T *sp;
+	va_list va;
+	int i;
+	unsigned int uc_link;
+
+	uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+	sp = (GREG_T *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= uc_link;
+	sp = (GREG_T *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_RBX] = (uintptr_t) &sp[uc_link];
+	ucp->uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;
+
+	sp[0] = (uintptr_t) &_start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+			ucp->uc_mcontext.gregs[REG_RDI] = va_arg (va, GREG_T);
+			break;
+		case 1:
+			ucp->uc_mcontext.gregs[REG_RSI] = va_arg (va, GREG_T);
+			break;
+		case 2:
+			ucp->uc_mcontext.gregs[REG_RDX] = va_arg (va, GREG_T);
+			break;
+		case 3:
+			ucp->uc_mcontext.gregs[REG_RCX] = va_arg (va, GREG_T);
+			break;
+		case 4:
+			ucp->uc_mcontext.gregs[REG_R8] = va_arg (va, GREG_T);
+			break;
+		case 5:
+			ucp->uc_mcontext.gregs[REG_R9] = va_arg (va, GREG_T);
+			break;
+		default:
+			sp[i - 5] = va_arg (va, GREG_T);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+#ifndef CUSTOM_IMPL
+extern __typeof(libucontext_makecontext) makecontext __attribute__((weak, __alias__("libucontext_makecontext")));
+#endif
diff -Naur a/libucontext/arch/x86_64/setcontext.S b/libucontext/arch/x86_64/setcontext.S
--- a/libucontext/arch/x86_64/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_setcontext;
+_libucontext_setcontext:
+	/* set all of the registers */
+	movq    40(%rdi), %r8
+	movq    48(%rdi), %r9
+	movq    56(%rdi), %r10
+	movq    64(%rdi), %r11
+	movq    72(%rdi), %r12
+	movq    80(%rdi), %r13
+	movq    88(%rdi), %r14
+	movq    96(%rdi), %r15
+	movq    112(%rdi), %rsi
+	movq    120(%rdi), %rbp
+	movq    128(%rdi), %rbx
+	movq    136(%rdi), %rdx
+	movq    144(%rdi), %rax
+	movq    152(%rdi), %rcx
+	movq    160(%rdi), %rsp
+
+	/* set the jump target by pushing it to the stack.
+	   ret will pop the new %rip from the stack, causing us to jump there. */
+	pushq   168(%rdi)
+
+	/* finally, set %rdi correctly. */
+	movq    104(%rdi), %rdi
+
+	/* we're all done here, return 0 */
+	xorl    %eax, %eax
+	ret
+
+#ifndef CUSTOM_IMPL
+.weak setcontext;
+setcontext = _libucontext_setcontext;
+#endif
diff -Naur a/libucontext/arch/x86_64/startcontext.S b/libucontext/arch/x86_64/startcontext.S
--- a/libucontext/arch/x86_64/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	movq	%rbx, %rsp
+	movq	(%rsp), %rdi
+	testq	%rdi, %rdi
+
+	/* if we have no linked context, lets get out of here */
+	je	no_linked_context
+
+	/* call setcontext to switch to the linked context */
+	call	_libucontext_setcontext
+	movq	%rax, %rdi
+
+no_linked_context:
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	call	_exit
+
+	/* something is really hosed, call hlt to force termination */
+	hlt
diff -Naur a/libucontext/arch/x86_64/swapcontext.S b/libucontext/arch/x86_64/swapcontext.S
--- a/libucontext/arch/x86_64/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_swapcontext;
+_libucontext_swapcontext:
+	/* copy all of the current registers into the ucontext structure pointed by
+	   the first argument */
+	movq	%r8, 40(%rdi)
+	movq	%r9, 48(%rdi)
+	movq	%r10, 56(%rdi)
+	movq	%r11, 64(%rdi)
+	movq	%r12, 72(%rdi)
+	movq	%r13, 80(%rdi)
+	movq	%r14, 88(%rdi)
+	movq	%r15, 96(%rdi)
+	movq	%rdi, 104(%rdi)
+	movq	%rsi, 112(%rdi)
+	movq	%rbp, 120(%rdi)
+	movq	%rbx, 128(%rdi)
+	movq	%rdx, 136(%rdi)
+	movq	$1, 144(%rdi)		/* $1 is %rax */
+	movq	%rcx, 152(%rdi)
+
+	/* the first argument on the stack is the jump target (%rip), so we store it in the RIP
+	   register in the ucontext structure. */
+	movq	(%rsp), %rcx
+	movq	%rcx, 168(%rdi)
+
+	/* finally take the stack pointer address (%rsp) offsetting by 8 to skip over the jump
+	   target. */
+	leaq	8(%rsp), %rcx
+	movq	%rcx, 160(%rdi)
+
+	/* set all of the registers to their new states, stored in the second
+	   ucontext structure */	
+	movq	40(%rsi), %r8
+	movq	48(%rsi), %r9
+	movq	56(%rsi), %r10
+	movq	64(%rsi), %r11
+	movq	72(%rsi), %r12
+	movq	80(%rsi), %r13
+	movq	88(%rsi), %r14
+	movq	96(%rsi), %r15
+	movq	104(%rsi), %rdi
+	movq	120(%rsi), %rbp
+	movq	128(%rsi), %rbx
+	movq	136(%rsi), %rdx
+	movq	144(%rsi), %rax
+	movq	152(%rsi), %rcx
+	movq	160(%rsi), %rsp
+
+	/* set the jump target by pushing it to the stack.
+	   ret will pop the new %rip from the stack, causing us to jump there. */
+	pushq	168(%rsi)
+
+	/* finally, set %rsi correctly since we do not need it anymore. */
+	movq	112(%rsi), %rsi
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+#ifndef CUSTOM_IMPL
+.weak swapcontext;
+swapcontext = _libucontext_swapcontext;
+#endif
diff -Naur a/libucontext/include/libucontext.h b/libucontext/include/libucontext.h
--- a/libucontext/include/libucontext.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/include/libucontext.h	2020-01-31 20:03:51.000000000 -0800
@@ -0,0 +1,126 @@
+#ifndef __LIBUCONTEXT_H
+#define __LIBUCONTEXT_H
+
+#include <stdint.h>
+
+/* Structure describing a signal stack.  */
+typedef struct
+  {
+    void *ss_sp;
+    size_t ss_size;
+    int ss_flags;
+  } libucontext_stack_t;
+
+typedef unsigned long int libucontext_sigset_t;
+
+#if defined(__aarch64__)
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct
+  {
+    unsigned long long int fault_address;
+    unsigned long long int regs[31];
+    unsigned long long int sp;
+    unsigned long long int pc;
+    unsigned long long int pstate;
+    /* This field contains extension records for additional processor
+       state such as the FP/SIMD state.  It has to match the definition
+       of the corresponding field in the sigcontext struct, see the
+       arch/arm64/include/uapi/asm/sigcontext.h linux header for details.  */
+    unsigned char __reserved[4096] __attribute__ ((__aligned__ (16)));
+  } libucontext_mcontext_t;
+
+/* Userlevel context.  */
+typedef struct libucontext_ucontext
+  {
+    unsigned long uc_flags;
+    struct libucontext_ucontext *uc_link;
+    libucontext_stack_t uc_stack;
+    libucontext_sigset_t uc_sigmask;
+    libucontext_mcontext_t uc_mcontext;
+  } libucontext_ucontext_t;
+#elif defined(__x86_64__)
+/* Type for general register.  */
+typedef long long int libucontext_greg_t;
+
+/* Container for all general registers.  */
+typedef libucontext_greg_t libucontext_gregset_t[23];
+
+struct libucontext_fpxreg
+{
+  unsigned short int significand[4];
+  unsigned short int exponent;
+  unsigned short int __glibc_reserved1[3];
+};
+
+struct libucontext_xmmreg
+{
+  uint32_t  element[4];
+};
+
+struct libucontext_fpstate
+{
+  /* 64-bit FXSAVE format.  */
+  uint16_t    cwd;
+  uint16_t    swd;
+  uint16_t    ftw;
+  uint16_t    fop;
+  uint64_t    rip;
+  uint64_t    rdp;
+  uint32_t    mxcsr;
+  uint32_t    mxcr_mask;
+  struct libucontext_fpxreg _st[8];
+  struct libucontext_xmmreg _xmm[16];
+  uint32_t    __libucontext_reserved1[24];
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct libucontext_fpstate *libucontext_fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct libucontext_mcontext
+  {
+    libucontext_gregset_t gregs;
+    /* Note that fpregs is a pointer.  */
+    libucontext_fpregset_t fpregs;
+    unsigned long long __reserved1 [8];
+} libucontext_mcontext_t;
+
+/* Userlevel context.  */
+typedef struct libucontext_ucontext
+  {
+    unsigned long int uc_flags;
+    struct libucontext_ucontext *uc_link;
+    libucontext_stack_t uc_stack;
+    libucontext_mcontext_t uc_mcontext;
+    libucontext_sigset_t uc_sigmask;
+    struct libucontext_fpstate __fpregs_mem;
+    unsigned long long int __ssp[4];
+  } libucontext_ucontext_t;
+#else
+#error "mcontext not implemented!"
+#endif
+
+/* Get user context and store it in variable pointed to by UCP.  */
+int libucontext_getcontext (libucontext_ucontext_t *__ucp);
+
+/* Set user context from information of variable pointed to by UCP.  */
+int libucontext_setcontext (const libucontext_ucontext_t *__ucp);
+
+/* Save current context in context variable pointed to by OUCP and set
+   context from variable pointed to by UCP.  */
+int libucontext_swapcontext (libucontext_ucontext_t *__restrict __oucp,
+      const libucontext_ucontext_t *__restrict __ucp);
+
+/* Manipulate user context UCP to continue with calling functions FUNC
+   and the ARGC-1 parameters following ARGC when the context is used
+   the next time in `setcontext' or `swapcontext'.
+
+   We cannot say anything about the parameters FUNC takes; `void'
+   is as good as any other choice.  */
+void libucontext_makecontext (libucontext_ucontext_t *__ucp, void (*__func) (void),
+       int __argc, ...);
+
+#endif
diff -Naur a/libucontext/test_libucontext.c b/libucontext/test_libucontext.c
--- a/libucontext/test_libucontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/test_libucontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,55 @@
+/*
+ * libucontext test program based on POSIX example program.
+ * Public domain.
+ */
+
+#include <stdio.h>
+#include <ucontext.h>
+#include <stdint.h>
+#include <string.h>
+
+
+static ucontext_t ctx[3];
+
+
+static void f1 (void) {
+	printf("start f1\n");
+	swapcontext(&ctx[1], &ctx[2]);
+	printf("finish f1\n");
+}
+
+
+static void f2 (void) {
+	printf("start f2\n");
+	swapcontext(&ctx[2], &ctx[1]);
+	printf("finish f2\n");
+}
+
+
+int main (int argc, const char *argv[]) {
+	char st1[8192];
+	char st2[8192];
+
+
+	/* poison each coroutine's stack memory for debugging purposes */
+	memset(st1, 'A', sizeof st1);
+	memset(st2, 'B', sizeof st2);
+
+
+	getcontext(&ctx[1]);
+	ctx[1].uc_stack.ss_sp = st1;
+	ctx[1].uc_stack.ss_size = sizeof st1;
+	ctx[1].uc_link = &ctx[0];
+	makecontext(&ctx[1], f1, 0);
+
+
+	getcontext(&ctx[2]);
+	ctx[2].uc_stack.ss_sp = st2;
+	ctx[2].uc_stack.ss_size = sizeof st2;
+	ctx[2].uc_link = &ctx[1];
+	makecontext(&ctx[2], f2, 0);
+
+
+	swapcontext(&ctx[0], &ctx[2]);
+	return 0;
+}
